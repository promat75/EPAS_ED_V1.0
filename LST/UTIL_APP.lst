C51 COMPILER V9.53.0.0   UTIL_APP                                                          01/28/2020 11:28:56 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE UTIL_APP
OBJECT MODULE PLACED IN .\HEX\UTIL_APP.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Sample\Utility\UTIL_APP.c LARGE OPTIMIZE(9,SIZE) BROWSE INCDIR(.\Platfor
                    -m\Include\;.\Platform\hal\;.\Sample\Include\;.\Sample\Utility\;.\Sample\EVB) DEFINE(__DEBUG,__INTERNAL_MODE) PRINT(.\LST
                    -\UTIL_APP.lst) TABS(2) OBJECT(.\HEX\UTIL_APP.obj)

line level    source

   1          
   2          /*******************************************************************************
   3            - Chip    : MG2470B
   4            - Vendor    : RadioPulse Inc, 2012.
   5            - Date    : 2014-01-23
   6            - Version   : V2.3
   7          
   8            [2014-01-23] V2.3
   9            - zPrintf_UartInterruptCheckPut() : enhanced.
  10          
  11            [2013-12-20] V2.2
  12            - zPrintf_UartInterruptCheckPut() : corrected.
  13          
  14            [2013-01-14] V2.1
  15            - zPrintf() : enhanced // UART interrupt enable/disable check
  16          
  17            [2012-04-25] V2.0
  18            - Initial Version for MG2470B(ChipID=0x71)
  19          *******************************************************************************/
  20          
  21          #include "include_top.h"
  22          
  23          #include "util_app.h"
  24          #include "util_sys.h"
  25          
  26          #include "uart.h"
  27          #include "wdt.h"
  28          #include "phy.h"
  29          
  30          //SB//
  31          #include "ib_sensor.h"
  32          
  33          
  34          #ifdef __MG2470_UART0_INCLUDE__
  35          void zPrintf_Uart0Put(UINT8 u8Data)
  36          {
  37   1        UINT8 u8PutData;
  38   1      
  39   1        if(xU0_IER & BIT1)
  40   1        {
  41   2          SYS_Uart0Put(u8Data);
  42   2        }
  43   1        else
  44   1        {
  45   2          u8PutData = u8Data;   
  46   2          SYS_Uart0Put_Poll(&u8PutData, 1);
  47   2        } 
  48   1      }
  49          
  50          UINT8 zScanf_Uart0Get(UINT8* pu8Data)
  51          {
  52   1        UINT8 u8Status;
  53   1      
C51 COMPILER V9.53.0.0   UTIL_APP                                                          01/28/2020 11:28:56 PAGE 2   

  54   1        if(xU0_IER & BIT0)
  55   1        {
  56   2          u8Status = SYS_Uart0Get(pu8Data);
  57   2        }
  58   1        else
  59   1        {
  60   2          u8Status = SYS_Uart0Get_Poll(pu8Data);
  61   2        }
  62   1      
  63   1        return u8Status;
  64   1      }
  65          #endif
  66          
  67          #ifdef __MG2470_UART1_INCLUDE__
  68          void zPrintf_Uart1Put(UINT8 u8Data)
  69          {
  70   1        UINT8 u8PutData;
  71   1      
  72   1        if(xU1_IER & BIT1)
  73   1        {
  74   2          SYS_Uart1Put(u8Data);
  75   2        }
  76   1        else
  77   1        {
  78   2          u8PutData = u8Data;   
  79   2          SYS_Uart1Put_Poll(&u8PutData, 1);
  80   2        }
  81   1      }
  82          
  83          UINT8 zScanf_Uart1Get(UINT8* pu8Data)
  84          {
  85   1        UINT8 u8Status;
  86   1      
  87   1        if(xU1_IER & BIT0)
  88   1        {
  89   2          u8Status = SYS_Uart1Get(pu8Data);
  90   2        }
  91   1        else
  92   1        {
  93   2          u8Status = SYS_Uart1Get_Poll(pu8Data);
  94   2        }
  95   1      
  96   1        return u8Status;
  97   1      }
  98          #endif
  99          
 100          void zPrintf_UartInterruptCheckPut(char* pu8Str)
 101          {
 102   1        UINT8 u8Loop;
 103   1        UINT8 u8EA;
 104   1      
 105   1        u8EA = EA;
 106   1        EA = 0;
 107   1        xU0_THR = 0x0A; xU0_THR = 0x0D; // LFCR
 108   1        xU1_THR = 0x0A; xU1_THR = 0x0D; // LFCR
 109   1        DPH = 0;
 110   1        EA = u8EA;
 111   1      
 112   1        while(!(xU0_LSR & BIT5)); while(!(xU1_LSR & BIT5)); // Checks UART0,1 Status
 113   1      
 114   1        for(u8Loop = 0; u8Loop < strlen(pu8Str); u8Loop++)
 115   1        {
C51 COMPILER V9.53.0.0   UTIL_APP                                                          01/28/2020 11:28:56 PAGE 3   

 116   2          u8EA = EA;
 117   2          EA = 0;
 118   2          xU0_THR = pu8Str[u8Loop];
 119   2          xU1_THR = pu8Str[u8Loop];
 120   2          DPH = 0;
 121   2          EA = u8EA;
 122   2        }
 123   1      }
 124          
 125          void zPrintf_UartInterruptCheck(UINT8 u8Port)
 126          {
 127   1        char* pu8Str;
 128   1      
 129   1        if(EA == 0)
 130   1        {
 131   2          pu8Str = " ## EA=0, Interrupt Disabled ##";
 132   2          zPrintf_UartInterruptCheckPut(pu8Str);
 133   2      
 134   2          if( (u8Port == 0) && (ES0 == 0) )
 135   2          {
 136   3            pu8Str = " ## UART0:Interrupt Disabled ##";
 137   3            zPrintf_UartInterruptCheckPut(pu8Str);
 138   3          }
 139   2          else if( (u8Port == 1) && (ES1 == 0) )
 140   2          {
 141   3            pu8Str = " ## UART1:Interrupt Disabled ##";
 142   3            zPrintf_UartInterruptCheckPut(pu8Str);
 143   3          }
 144   2      
 145   2          EA = 0;
 146   2          WDT = 0x55;
 147   2          WDT = 0xAA;
 148   2          WDT = 0x0A;
 149   2          WDT_CLK_ON;
 150   2          while(1);   // Watchdog Reset
 151   2        }
 152   1        else
 153   1        {
 154   2          if( (u8Port == 0) && (ES0 == 0) )
 155   2          {
 156   3            pu8Str = " ## UART0 : Interrupt Disabled ##";
 157   3            zPrintf_UartInterruptCheckPut(pu8Str);
 158   3          }
 159   2          else if( (u8Port == 1) && (ES1 == 0) )
 160   2          {
 161   3            pu8Str = " ## UART1 : Interrupt Disabled ##";
 162   3            zPrintf_UartInterruptCheckPut(pu8Str);
 163   3          }
 164   2        }
 165   1      }
 166          
 167          ///////////////////////////////////////////////////////////////////////////////////////////////
 168          /// 
 169          ///   Formats a series of strings and numeric values. It builds a string to write via UART.
 170          /// This is similar to the printf() of the general C-Language.
 171          ///
 172          /// @param  u8Port  : UART port. 0=UART0, 1=UART1.
 173          /// @param  fmt   : Pointer to a format string.
 174          /// @return void
 175          /// 
 176          ///////////////////////////////////////////////////////////////////////////////////////////////
 177          void zPrintf(UINT8 u8Port, char *fmt, ...)
C51 COMPILER V9.53.0.0   UTIL_APP                                                          01/28/2020 11:28:56 PAGE 4   

 178          {
 179   1        va_list arg_ptr;
 180   1        char    acLocalText[64];
 181   1        UINT8 ib;
 182   1      
 183   1      //  SYS_WdtSet(10000);
 184   1        
 185   1        zPrintf_UartInterruptCheck(u8Port);
 186   1      
 187   1        for(ib=0 ; ib<64 ; ib++) 
 188   1        {
 189   2          acLocalText[ib] = 0x00;
 190   2        }
 191   1      
 192   1        va_start(arg_ptr, fmt);
 193   1        vsprintf(acLocalText, fmt, arg_ptr);
 194   1        va_end(arg_ptr);
 195   1      
 196   1        if(u8Port & 0x01)   // SERIAL PORT1
 197   1        {
 198   2          #ifdef __MG2470_UART1_INCLUDE__
 199   2          for(ib=0 ; ib<64 ; ib++) 
 200   2          {
 201   3            if(acLocalText[ib] != 0)
 202   3            {
 203   4              #if _UARTDEBUG_MODE
                      zPrintf_Uart1Put(acLocalText[ib]);
                      #endif
 206   4              if(acLocalText[ib] == KEYBOARD_LineFeed)  
 207   4              {
 208   5                #if _UARTDEBUG_MODE
                        zPrintf_Uart1Put(KEYBOARD_CarryRet);      
                        #endif
 211   5              }
 212   4            }
 213   3            else
 214   3            {
 215   4              break;
 216   4            }
 217   3          } 
 218   2          #endif
 219   2        }
 220   1        else          // SERIAL PORT0
 221   1        {
 222   2          #ifdef __MG2470_UART0_INCLUDE__
 223   2          for(ib=0 ; ib<64 ; ib++)
 224   2          {
 225   3            if(acLocalText[ib] != 0)
 226   3            {     
 227   4              zPrintf_Uart0Put(acLocalText[ib]);
 228   4              if(acLocalText[ib] == KEYBOARD_LineFeed)  
 229   4              {
 230   5                zPrintf_Uart0Put(KEYBOARD_CarryRet);
 231   5              }
 232   4            }
 233   3            else  
 234   3            {
 235   4              break;
 236   4            }
 237   3          } 
 238   2          #endif
 239   2        }
C51 COMPILER V9.53.0.0   UTIL_APP                                                          01/28/2020 11:28:56 PAGE 5   

 240   1      }
 241          
 242          ///////////////////////////////////////////////////////////////////////////////////////////////
 243          /// 
 244          ///   Stores 16-bit input hexa-decimal data by keyboard. When "ENTER" is pressed, the value is stored.
 245          /// This is similar to the scanf() of the general C-Language.
 246          ///
 247          /// @param  u8Port    : UART port. 0=UART0, 1=UART1.
 248          /// @param  pu16InValue : Pointer to the variable in which input data is stored.
 249          /// @return void
 250          /// 
 251          ///////////////////////////////////////////////////////////////////////////////////////////////
 252          void zScanf(UINT8 u8Port, UINT16* pu16InValue)
 253          {
 254   1        char    cInteger;
 255   1        UINT8 u8KeyInput;
 256   1        UINT8 ib;
 257   1      
 258   1        ib = 0;
 259   1        *pu16InValue = 0;
 260   1      
 261   1        while(1) 
 262   1        {   
 263   2          SYS_WdtSet(10000);
 264   2      
 265   2          if(u8Port & 0x01)
 266   2          {
 267   3            #ifdef __MG2470_UART1_INCLUDE__
 268   3            if(zScanf_Uart1Get(&u8KeyInput)) 
 269   3            {
 270   4              cInteger = toint(u8KeyInput);
 271   4      
 272   4              if(cInteger != -1) 
 273   4              {
 274   5                if(ib != 4)
 275   5                {
 276   6                  zPrintf_Uart1Put(u8KeyInput);
 277   6                  *pu16InValue <<= 4;
 278   6                  *pu16InValue |= cInteger;
 279   6                  ib++;
 280   6                }
 281   5              }
 282   4              else 
 283   4              {
 284   5                if( (u8KeyInput == KEYBOARD_BACK) && (ib) )   // BackSpace
 285   5                {
 286   6                  zPrintf_Uart1Put(KEYBOARD_BACK);
 287   6                  zPrintf_Uart1Put(KEYBOARD_SPACE);
 288   6                  zPrintf_Uart1Put(KEYBOARD_BACK);
 289   6                  *pu16InValue = *pu16InValue >> 4;
 290   6                  ib--;
 291   6                }
 292   5              
 293   5                if(u8KeyInput == KEYBOARD_CarryRet)
 294   5                {
 295   6                  break;
 296   6                }
 297   5              }
 298   4            } 
 299   3            #endif    
 300   3          }
 301   2          else
C51 COMPILER V9.53.0.0   UTIL_APP                                                          01/28/2020 11:28:56 PAGE 6   

 302   2          {
 303   3            #ifdef __MG2470_UART0_INCLUDE__
 304   3            if(zScanf_Uart0Get(&u8KeyInput)) 
 305   3            {
 306   4              cInteger = toint(u8KeyInput);
 307   4      
 308   4              if(cInteger != -1) 
 309   4              {
 310   5                if(ib != 4)
 311   5                {
 312   6                  zPrintf_Uart0Put(u8KeyInput);
 313   6                  *pu16InValue <<= 4;       
 314   6                  *pu16InValue |= cInteger;
 315   6                  ib++;
 316   6                }
 317   5              }
 318   4              else 
 319   4              {       
 320   5                if( (u8KeyInput == KEYBOARD_BACK) && (ib) )   // BackSpace
 321   5                {
 322   6                  zPrintf_Uart0Put(KEYBOARD_BACK);
 323   6                  zPrintf_Uart0Put(KEYBOARD_SPACE);
 324   6                  zPrintf_Uart0Put(KEYBOARD_BACK);
 325   6                  *pu16InValue = *pu16InValue >> 4;
 326   6                  ib--;
 327   6                }
 328   5      
 329   5                if(u8KeyInput == KEYBOARD_CarryRet)   // Enter
 330   5                {
 331   6                  break;
 332   6                }       
 333   5              }
 334   4            }     
 335   3            #endif
 336   3            
 337   3          }
 338   2        
 339   2        }
 340   1      
 341   1      }
 342          
 343          ///////////////////////////////////////////////////////////////////////////////////////////////
 344          /// 
 345          ///   Stores 8-bit input hexa-decimal data by keyboard. When "ENTER" is pressed, the value is stored.
 346          /// This is similar to the scanf() of the general C-Language.
 347          ///
 348          /// @param  u8Port    : UART port. 0=UART0, 1=UART1.
 349          /// @param  pu8InValue  : Pointer to the variable in which input data is stored.
 350          /// @return void
 351          /// 
 352          ///////////////////////////////////////////////////////////////////////////////////////////////
 353          void zScanfByte(UINT8 u8Port, UINT8* pu8InValue)
 354          {
 355   1        char    cInteger;
 356   1        UINT8 u8KeyInput;
 357   1        UINT8 u8DigitLocation;
 358   1      
 359   1        u8DigitLocation = 0;
 360   1        *pu8InValue = 0;
 361   1      
 362   1        while(1) 
 363   1        {   
C51 COMPILER V9.53.0.0   UTIL_APP                                                          01/28/2020 11:28:56 PAGE 7   

 364   2          SYS_WdtSet(10000);
 365   2      
 366   2          if(u8Port & 0x01)
 367   2          {
 368   3            #ifdef __MG2470_UART1_INCLUDE__
 369   3            if(zScanf_Uart1Get(&u8KeyInput)) 
 370   3            {
 371   4              cInteger = toint(u8KeyInput);
 372   4      
 373   4              if(cInteger != -1) 
 374   4              {
 375   5                if(u8DigitLocation != 2)
 376   5                {
 377   6                  zPrintf_Uart1Put(u8KeyInput);
 378   6                  *pu8InValue <<= 4;
 379   6                  *pu8InValue |= cInteger;
 380   6                  u8DigitLocation++;
 381   6                }
 382   5              }
 383   4              else 
 384   4              {
 385   5                if( (u8KeyInput == KEYBOARD_BACK) && (u8DigitLocation) )  // BackSpace
 386   5                {
 387   6                  zPrintf_Uart1Put(KEYBOARD_BACK);
 388   6                  zPrintf_Uart1Put(KEYBOARD_SPACE);
 389   6                  zPrintf_Uart1Put(KEYBOARD_BACK);
 390   6                  *pu8InValue = *pu8InValue >> 4;
 391   6                  u8DigitLocation--;
 392   6                }
 393   5              
 394   5                if(u8KeyInput == KEYBOARD_CarryRet)
 395   5                {
 396   6                  break;
 397   6                }
 398   5              }
 399   4            } 
 400   3            #endif    
 401   3          }
 402   2          else
 403   2          {
 404   3            #ifdef __MG2470_UART0_INCLUDE__
 405   3            if(zScanf_Uart0Get(&u8KeyInput)) 
 406   3            {
 407   4              cInteger = toint(u8KeyInput);
 408   4      
 409   4              if(cInteger != -1) 
 410   4              {
 411   5                if(u8DigitLocation != 2)
 412   5                {
 413   6                  zPrintf_Uart0Put(u8KeyInput);
 414   6                  *pu8InValue <<= 4;
 415   6                  *pu8InValue |= cInteger;
 416   6                  u8DigitLocation++;
 417   6                }
 418   5              }
 419   4              else 
 420   4              {       
 421   5                if( (u8KeyInput == KEYBOARD_BACK) && (u8DigitLocation) )  // BackSpace
 422   5                {
 423   6                  zPrintf_Uart0Put(KEYBOARD_BACK);
 424   6                  zPrintf_Uart0Put(KEYBOARD_SPACE);
 425   6                  zPrintf_Uart0Put(KEYBOARD_BACK);
C51 COMPILER V9.53.0.0   UTIL_APP                                                          01/28/2020 11:28:56 PAGE 8   

 426   6                  *pu8InValue = *pu8InValue >> 4;
 427   6                  u8DigitLocation--;
 428   6                }
 429   5              
 430   5                if(u8KeyInput == KEYBOARD_CarryRet)
 431   5                {
 432   6                  break;
 433   6                }
 434   5              }
 435   4            }     
 436   3            #endif
 437   3            
 438   3          }
 439   2        
 440   2        }
 441   1      
 442   1      }
 443          
 444          ///////////////////////////////////////////////////////////////////////////////////////////////
 445          /// 
 446          ///   Stores 16-bit input decimal data by keyboard. When "ENTER" is pressed, the value is stored.
 447          /// This is similar to the scanf() of the general C-Language.
 448          ///
 449          /// @param  u8Port    : UART port. 0=UART0, 1=UART1.
 450          /// @param  pu16InValue : Pointer to the variable in which input data is stored.
 451          /// @return UINT8. Status. 1=Success, 0=Failed(Input data is out of 16-bit range).
 452          /// 
 453          ///////////////////////////////////////////////////////////////////////////////////////////////
 454          UINT8 zScanf_Decimal(UINT8 u8Port, UINT16 *pu16InValue)
 455          {
 456   1        char    cInteger;
 457   1        UINT8 u8KeyInput;
 458   1        UINT8 ib;
 459   1        UINT8 au8Digit[5];
 460   1        UINT32  u32Temp;
 461   1      
 462   1        ib = 0;
 463   1        *pu16InValue = 0;
 464   1        au8Digit[0] = 0;
 465   1        au8Digit[1] = 0;
 466   1        au8Digit[2] = 0;
 467   1        au8Digit[3] = 0;
 468   1        au8Digit[4] = 0;
 469   1      
 470   1        while(1)
 471   1        {
 472   2          SYS_WdtSet(10000);
 473   2      
 474   2          if(u8Port & 0x01)
 475   2          {
 476   3            #ifdef __MG2470_UART1_INCLUDE__
 477   3            if(zScanf_Uart1Get(&u8KeyInput)) 
 478   3            {
 479   4              if( (u8KeyInput >= '0') && (u8KeyInput <= '9') )
 480   4              {
 481   5                cInteger = u8KeyInput - '0';
 482   5      
 483   5                if(ib < 4)
 484   5                {
 485   6                  zPrintf_Uart1Put(u8KeyInput);
 486   6                  au8Digit[4] = au8Digit[3];
 487   6                  au8Digit[3] = au8Digit[2];
C51 COMPILER V9.53.0.0   UTIL_APP                                                          01/28/2020 11:28:56 PAGE 9   

 488   6                  au8Digit[2] = au8Digit[1];
 489   6                  au8Digit[1] = au8Digit[0];
 490   6                  au8Digit[0] = cInteger;
 491   6                  ib++;
 492   6                }
 493   5                else if(ib == 4)
 494   5                {         
 495   6                  u32Temp = au8Digit[3];  
 496   6                  u32Temp *= 10000;
 497   6                  u32Temp += (au8Digit[2] * 1000);
 498   6                  u32Temp += (au8Digit[1] * 100);
 499   6                  u32Temp += (au8Digit[0] * 10);            
 500   6                  u32Temp += cInteger;
 501   6      
 502   6                  if(u32Temp & 0xFFFF0000)
 503   6                  {
 504   7                  }
 505   6                  else
 506   6                  {
 507   7                    zPrintf_Uart1Put(u8KeyInput);
 508   7                    au8Digit[4] = au8Digit[3];
 509   7                    au8Digit[3] = au8Digit[2];
 510   7                    au8Digit[2] = au8Digit[1];
 511   7                    au8Digit[1] = au8Digit[0];
 512   7                    au8Digit[0] = cInteger;
 513   7                    ib++;
 514   7                  }         
 515   6                }
 516   5              }
 517   4              else
 518   4              {
 519   5                if( (u8KeyInput == KEYBOARD_BACK) && (ib) )   // BackSpace
 520   5                {         
 521   6                  zPrintf_Uart1Put(KEYBOARD_BACK);
 522   6                  zPrintf_Uart1Put(KEYBOARD_SPACE);
 523   6                  zPrintf_Uart1Put(KEYBOARD_BACK);
 524   6      
 525   6                  au8Digit[0] = au8Digit[1];
 526   6                  au8Digit[1] = au8Digit[2];
 527   6                  au8Digit[2] = au8Digit[3];
 528   6                  au8Digit[3] = au8Digit[4];
 529   6                  au8Digit[4] = 0;
 530   6                  ib--;
 531   6                }
 532   5              
 533   5                if(u8KeyInput == KEYBOARD_CarryRet) 
 534   5                {
 535   6                  u32Temp = au8Digit[4];  
 536   6                  u32Temp *= 10000;
 537   6                  u32Temp += (au8Digit[3] * 1000);
 538   6                  u32Temp += (au8Digit[2] * 100);
 539   6                  u32Temp += (au8Digit[1] * 10);
 540   6                  u32Temp += (au8Digit[0] * 1);
 541   6                  if(u32Temp & 0xFFFF0000)
 542   6                  {
 543   7                    return  0;
 544   7                  }
 545   6                  else  
 546   6                  {
 547   7                    *pu16InValue = u32Temp;
 548   7                    return  1;
 549   7                  }
C51 COMPILER V9.53.0.0   UTIL_APP                                                          01/28/2020 11:28:56 PAGE 10  

 550   6                }       
 551   5              }     
 552   4            } 
 553   3            #endif
 554   3          }
 555   2          else
 556   2          {
 557   3            #ifdef __MG2470_UART0_INCLUDE__
 558   3            if(zScanf_Uart0Get(&u8KeyInput)) 
 559   3            {
 560   4              if( (u8KeyInput >= '0') && (u8KeyInput <= '9') )
 561   4              {
 562   5                cInteger = u8KeyInput - '0';
 563   5      
 564   5                if(ib < 4)
 565   5                {
 566   6                  zPrintf_Uart0Put(u8KeyInput);
 567   6                  au8Digit[4] = au8Digit[3];
 568   6                  au8Digit[3] = au8Digit[2];
 569   6                  au8Digit[2] = au8Digit[1];
 570   6                  au8Digit[1] = au8Digit[0];
 571   6                  au8Digit[0] = cInteger;
 572   6                  ib++;
 573   6                }
 574   5                else if(ib == 4)
 575   5                {         
 576   6                  u32Temp = au8Digit[3];  
 577   6                  u32Temp *= 10000;
 578   6                  u32Temp += (au8Digit[2] * 1000);
 579   6                  u32Temp += (au8Digit[1] * 100);
 580   6                  u32Temp += (au8Digit[0] * 10);            
 581   6                  u32Temp += cInteger;
 582   6      
 583   6                  if(u32Temp & 0xFFFF0000)
 584   6                  {
 585   7                  }
 586   6                  else
 587   6                  {
 588   7                    zPrintf_Uart0Put(u8KeyInput);
 589   7                    au8Digit[4] = au8Digit[3];
 590   7                    au8Digit[3] = au8Digit[2];
 591   7                    au8Digit[2] = au8Digit[1];
 592   7                    au8Digit[1] = au8Digit[0];
 593   7                    au8Digit[0] = cInteger;
 594   7                    ib++;
 595   7                  }         
 596   6                }
 597   5              }
 598   4              else
 599   4              {
 600   5                if( (u8KeyInput == KEYBOARD_BACK) && (ib) )   // BackSpace
 601   5                {         
 602   6                  zPrintf_Uart0Put(KEYBOARD_BACK);
 603   6                  zPrintf_Uart0Put(KEYBOARD_SPACE);
 604   6                  zPrintf_Uart0Put(KEYBOARD_BACK);
 605   6      
 606   6                  au8Digit[0] = au8Digit[1];
 607   6                  au8Digit[1] = au8Digit[2];
 608   6                  au8Digit[2] = au8Digit[3];
 609   6                  au8Digit[3] = au8Digit[4];
 610   6                  au8Digit[4] = 0;
 611   6                  ib--;
C51 COMPILER V9.53.0.0   UTIL_APP                                                          01/28/2020 11:28:56 PAGE 11  

 612   6                }
 613   5              
 614   5                if(u8KeyInput == KEYBOARD_CarryRet) 
 615   5                {
 616   6                  u32Temp = au8Digit[4];  
 617   6                  u32Temp *= 10000;
 618   6                  u32Temp += (au8Digit[3] * 1000);
 619   6                  u32Temp += (au8Digit[2] * 100);
 620   6                  u32Temp += (au8Digit[1] * 10);
 621   6                  u32Temp += (au8Digit[0] * 1);
 622   6                  if(u32Temp & 0xFFFF0000)
 623   6                  {
 624   7                    return  0;
 625   7                  }
 626   6                  else  
 627   6                  {
 628   7                    *pu16InValue = u32Temp;
 629   7                    return  1;
 630   7                  }
 631   6                }       
 632   5              }     
 633   4            } 
 634   3            #endif
 635   3          } 
 636   2        }
 637   1      }
 638          
 639          ///////////////////////////////////////////////////////////////////////////////////////////////
 640          /// 
 641          ///   Global variable for virtual timer(Number 0). This is the number of remained ticks.
 642          /// This is decreased by 1 every TIMER0 interrupts when it is not 0.
 643          /// 
 644          ///////////////////////////////////////////////////////////////////////////////////////////////
 645          UINT16  gu16VirtualTimer0 = 0;
 646          
 647          ///////////////////////////////////////////////////////////////////////////////////////////////
 648          /// 
 649          ///   Global variable for virtual timer(Number 1). This is the number of remained ticks.
 650          /// This is decreased by 1 every TIMER0 interrupts when it is not 0.
 651          /// 
 652          ///////////////////////////////////////////////////////////////////////////////////////////////
 653          UINT16  gu16VirtualTimer1 = 0;
 654          UINT16  gu16VirtualTimer2 = 0;
 655          UINT16  gu16VirtualTimer3 = 0;
 656          UINT16  gu16VirtualTimer4 = 0;
 657          
 658          ///////////////////////////////////////////////////////////////////////////////////////////////
 659          /// 
 660          ///   Sets the number of ticks of virtual timers which is counted down.
 661          ///
 662          /// @param  u8VirtualTimerNum   : 0=Virtual timer 0, 1=Virtual timer 1.
 663          /// @param  u16Timer0Tick   : Number of ticks to be counted down by TIMER0 interrupts.
 664          /// @return void
 665          /// 
 666          ///////////////////////////////////////////////////////////////////////////////////////////////
 667          void AppLib_VirtualTimerSet(UINT8 u8VirtualTimerNum, UINT16 u16Timer0Tick)
 668          {
 669   1        UINT8 u8ET0;
 670   1      
 671   1        u8ET0 = ET0;
 672   1        ET0 = 0;
 673   1      
C51 COMPILER V9.53.0.0   UTIL_APP                                                          01/28/2020 11:28:56 PAGE 12  

 674   1        if(u8VirtualTimerNum == 0)
 675   1        {
 676   2          gu16VirtualTimer0 = u16Timer0Tick;
 677   2        }
 678   1        else if(u8VirtualTimerNum == 1)
 679   1        {
 680   2          gu16VirtualTimer1 = u16Timer0Tick;
 681   2        }
 682   1        else if(u8VirtualTimerNum == 2)
 683   1        {
 684   2          gu16VirtualTimer2 = u16Timer0Tick;
 685   2        }
 686   1        else if(u8VirtualTimerNum == 3)
 687   1        {
 688   2          gu16VirtualTimer3 = u16Timer0Tick;
 689   2        }
 690   1        else if(u8VirtualTimerNum == 4)
 691   1        {
 692   2          gu16VirtualTimer4 = u16Timer0Tick;
 693   2        }
 694   1        
 695   1        ET0 = u8ET0;  
 696   1      }
 697          
 698          ///////////////////////////////////////////////////////////////////////////////////////////////
 699          /// 
 700          ///   Gets the number of current ticks of virtual timers.
 701          ///
 702          /// @param  u8VirtualTimerNum   : 0=Virtual timer 0, 1=Virtual timer 1.
 703          /// @return UINT16. Number of current ticks.
 704          /// 
 705          ///////////////////////////////////////////////////////////////////////////////////////////////
 706          UINT16 AppLib_VirtualTimerGet(UINT8 u8VirtualTimerNum)
 707          {
 708   1        UINT16  u16TimerValue;
 709   1      
 710   1        if(u8VirtualTimerNum == 0)
 711   1        {
 712   2          u16TimerValue = gu16VirtualTimer0;
 713   2        }
 714   1        else if(u8VirtualTimerNum == 1)
 715   1        {
 716   2          u16TimerValue = gu16VirtualTimer1;
 717   2        }
 718   1        else if(u8VirtualTimerNum == 2)
 719   1        {
 720   2          u16TimerValue = gu16VirtualTimer2;
 721   2        }
 722   1        else if(u8VirtualTimerNum == 3)
 723   1        {
 724   2          u16TimerValue = gu16VirtualTimer3;
 725   2        }
 726   1        else
 727   1        {
 728   2          u16TimerValue = 0;
 729   2        }
 730   1      
 731   1        #if _TIMER0_USE
                  return u16TimerValue;
                #else
 734   1          return 0;
 735   1        #endif
C51 COMPILER V9.53.0.0   UTIL_APP                                                          01/28/2020 11:28:56 PAGE 13  

 736   1      }
 737          
 738          ///////////////////////////////////////////////////////////////////////////////////////////////
 739          /// 
 740          ///   Global variable which contains parameters for MIB(MAC Information Base).
 741          /// MIB has parameters for IEEE 802.15.4 network. It consists of channel, network(short) address, etc.
 742          /// If not needed, this may be removed.
 743          /// 
 744          ///////////////////////////////////////////////////////////////////////////////////////////////
 745          tMAC_INFO_BASE  gtMIB;
 746          
 747          ///////////////////////////////////////////////////////////////////////////////////////////////
 748          /// 
 749          ///   Makes an IEEE 802.15.4 data packet.
 750          ///
 751          /// @param  ptMacDataReq    : Pointer to the parameter variable for data packet to be made.
 752          /// @param  pu8Psdu     : Pointer to the buffer in which the data packet is constructed.
 753          /// @param  pu8PsduLen    : Pointer to the variable which indicates the length of constructed packet.
 754          /// @return UINT8. Status.
 755          /// 
 756          ///////////////////////////////////////////////////////////////////////////////////////////////
 757          UINT8 AppLib_MacDataFrameMake(tMAC_DATA_REQ* ptMacDataReq, UINT8* pu8Psdu, UINT8* pu8PsduLen)
 758          {
 759   1        UINT8 u8Len;
 760   1        UINT8 u8IntraPanSubfield;
 761   1      
 762   1        // Get u8IntraPanSubfield
 763   1        if( (ptMacDataReq->u8DstMode == maccAddrMode_16bit) || (ptMacDataReq->u8DstMode == maccAddrMode_64bit) )
 764   1        {
 765   2          if(ptMacDataReq->u16DstPanID == gtMIB.u16PanID)
 766   2          {
 767   3            u8IntraPanSubfield = 1;
 768   3          }
 769   2          else
 770   2          {
 771   3            u8IntraPanSubfield = 0;
 772   3          }
 773   2        }
 774   1        else
 775   1        {
 776   2          u8IntraPanSubfield = 0;
 777   2        }
 778   1      
 779   1        //-------------------------------------------------------------------------------
 780   1        // FrameControl_Low Field
 781   1        //-------------------------------------------------------------------------------
 782   1        //  b7    b6    b5    b4      b3    b2-b0
 783   1        //-------------------------------------------------------------------------------
 784   1        //  reserved  IntraPan  AckReq  FramePend Security  FrameType
 785   1        //------------------------------------------------------------------------------- 
 786   1        pu8Psdu[0] = maccFrame_Data;
 787   1        if(ptMacDataReq->u8TxOption & BIT0)
 788   1        {
 789   2          pu8Psdu[0] |= maccFCL_AckReq;
 790   2        }
 791   1        if(u8IntraPanSubfield)
 792   1        {
 793   2          pu8Psdu[0] |= maccFCL_IntraPan;
 794   2        }
 795   1      
 796   1        //------------------------------------------------------------------------------- 
 797   1        // FrameControl_High Field
C51 COMPILER V9.53.0.0   UTIL_APP                                                          01/28/2020 11:28:56 PAGE 14  

 798   1        //------------------------------------------------------------------------------- 
 799   1        //  b7-b6   b5-b4     b3-b2   b1-b0
 800   1        //------------------------------------------------------------------------------- 
 801   1        //  SrcMode   OobCode[3:2]    DstMode   OobCode[1:0]
 802   1        //-------------------------------------------------------------------------------
 803   1        pu8Psdu[1] = (ptMacDataReq->u8TxOption & BIT_5N4) >> 4;
 804   1        pu8Psdu[1] |= (ptMacDataReq->u8TxOption & BIT_7N6) >> 2;
 805   1        if(ptMacDataReq->u8DstMode == maccAddrMode_None)
 806   1        {
 807   2        }
 808   1        else if(ptMacDataReq->u8DstMode == maccAddrMode_16bit)
 809   1        {
 810   2          pu8Psdu[1] |= 0x08;
 811   2        }
 812   1        else if(ptMacDataReq->u8DstMode == maccAddrMode_64bit)
 813   1        {
 814   2          pu8Psdu[1] |= 0x0C;
 815   2        }
 816   1        else
 817   1        {
 818   2          return  maccSTA_INVALID_PARAMETER;
 819   2        }
 820   1        if(ptMacDataReq->u8SrcMode == maccAddrMode_None)
 821   1        {
 822   2        }
 823   1        else if(ptMacDataReq->u8SrcMode == maccAddrMode_16bit)
 824   1        {
 825   2          pu8Psdu[1] |= 0x80;
 826   2        }
 827   1        else if(ptMacDataReq->u8SrcMode == maccAddrMode_64bit)
 828   1        {
 829   2          pu8Psdu[1] |= 0xC0;
 830   2        }
 831   1        else
 832   1        {
 833   2          return  maccSTA_INVALID_PARAMETER;
 834   2        }
 835   1        
 836   1        // Sequence Number Field
 837   1        pu8Psdu[2] = ++gtMIB.u8DSN;
 838   1      
 839   1        u8Len = 3;
 840   1      
 841   1        // Destination Addressing Field
 842   1        if(ptMacDataReq->u8DstMode == maccAddrMode_16bit)
 843   1        {
 844   2          pu8Psdu[u8Len + 0] = ptMacDataReq->u16DstPanID;
 845   2          pu8Psdu[u8Len + 1] = ptMacDataReq->u16DstPanID >> 8;
 846   2          pu8Psdu[u8Len + 2] = ptMacDataReq->uDstAddr.u16Short;
 847   2          pu8Psdu[u8Len + 3] = ptMacDataReq->uDstAddr.u16Short >> 8;
 848   2          u8Len += 4;
 849   2        }
 850   1        else if(ptMacDataReq->u8DstMode == maccAddrMode_64bit)
 851   1        {
 852   2          pu8Psdu[u8Len + 0] = ptMacDataReq->u16DstPanID;
 853   2          pu8Psdu[u8Len + 1] = ptMacDataReq->u16DstPanID >> 8;
 854   2          rpmemcpy(&pu8Psdu[u8Len + 2], ptMacDataReq->uDstAddr.au8Ext, 8);
 855   2          u8Len += 10;
 856   2        }
 857   1      
 858   1        // Source Addressing Field
 859   1        if(ptMacDataReq->u8SrcMode == maccAddrMode_16bit)
C51 COMPILER V9.53.0.0   UTIL_APP                                                          01/28/2020 11:28:56 PAGE 15  

 860   1        {
 861   2          if(u8IntraPanSubfield)
 862   2          {
 863   3            pu8Psdu[u8Len + 0] = gtMIB.u16ShortAddr;
 864   3            pu8Psdu[u8Len + 1] = gtMIB.u16ShortAddr >> 8;
 865   3            u8Len += 2;
 866   3          }
 867   2          else    // If IntraPanSubField = 1,, SrcPanID Field is not present
 868   2          {
 869   3            pu8Psdu[u8Len + 0] = gtMIB.u16PanID;
 870   3            pu8Psdu[u8Len + 1] = gtMIB.u16PanID >> 8;
 871   3            pu8Psdu[u8Len + 2] = gtMIB.u16ShortAddr;
 872   3            pu8Psdu[u8Len + 3] = gtMIB.u16ShortAddr >> 8;
 873   3            u8Len += 4;
 874   3          }
 875   2        }
 876   1        else if(ptMacDataReq->u8SrcMode == maccAddrMode_64bit)
 877   1        {
 878   2          if(u8IntraPanSubfield)
 879   2          {
 880   3            rpmemcpy(&pu8Psdu[u8Len + 0], gtMIB.au8IEEEAddr, 8);
 881   3            u8Len += 8;
 882   3          }
 883   2          else    // If IntraPanSubField = 1,, SrcPanID Field is not present
 884   2          {
 885   3            pu8Psdu[u8Len + 0] = gtMIB.u16PanID;
 886   3            pu8Psdu[u8Len + 1] = gtMIB.u16PanID >> 8;
 887   3            rpmemcpy(&pu8Psdu[u8Len + 2], gtMIB.au8IEEEAddr, 8);
 888   3            u8Len += 10;
 889   3          }
 890   2        }
 891   1      
 892   1        // Check Frame's Length
 893   1        *pu8PsduLen = u8Len;            // MAC Header's Length
 894   1        *pu8PsduLen += ptMacDataReq->u8MsduLen; // Add MAC Payload(MSDU)'s Length
 895   1        *pu8PsduLen += 2;             // Add MAC Footer(FCS)'s Length. This field is added automatically by MG2410 when
             - transmitting
 896   1        if(*pu8PsduLen > 127)
 897   1        {
 898   2          return  maccSTA_FRAME_TOO_LONG;
 899   2        }
 900   1        // Copy MAC Payload
 901   1        rpmemcpy(&pu8Psdu[u8Len + 0], ptMacDataReq->pu8Msdu, ptMacDataReq->u8MsduLen);
 902   1      
 903   1        return  maccSTA_SUCCESS;
 904   1      }
 905          
 906          ///////////////////////////////////////////////////////////////////////////////////////////////
 907          /// 
 908          ///   Transmits a packet in TXFIFO.
 909          ///
 910          /// @param  u8NoAckRetry    : Number of retries when an ACK is not received.
 911          /// @param  u8BackoffRetry  : Number of retries when CCA(Channel Clear Assessment) is failed.
 912          /// @return UINT8. Status.
 913          /// 
 914          ///////////////////////////////////////////////////////////////////////////////////////////////
 915          UINT8 AppLib_TxFifoTransmit(UINT8 u8NoAckRetry, UINT8 u8BackoffRetry)
 916          {
 917   1        UINT8 u8Status;
 918   1        UINT8 u8LoopNoAck;
 919   1        UINT8 u8LoopBackoff;
 920   1        UINT8 u8NoAckTxNum;
C51 COMPILER V9.53.0.0   UTIL_APP                                                          01/28/2020 11:28:56 PAGE 16  

 921   1        UINT8 u8BackoffTxNum;
 922   1        
 923   1        Retry_count=0;
 924   1        
 925   1        u8NoAckTxNum = u8NoAckRetry + 1;
 926   1        u8BackoffTxNum = u8BackoffRetry + 1;
 927   1      
 928   1        for(u8LoopNoAck=0 ; u8LoopNoAck < u8NoAckTxNum ; u8LoopNoAck++)
 929   1        { 
 930   2          // 무선 상태 체크 Delay : 무선 상태 사용 가능 여부 
 931   2          for(u8LoopBackoff=0 ; u8LoopBackoff < u8BackoffTxNum ; u8LoopBackoff++)
 932   2          {
 933   3            u8Status = HAL_TxFifoTransmit();      // 함수 내부에서 자체 delay를 수행 하고 있음
 934   3            if( (u8Status == RETURN_PHY_MODEM_BUSY)
 935   3            ||  (u8Status == RETURN_PHY_CCA_FAILURE) )
 936   3            {
 937   4              // Here, Backoff Delay
 938   4              //Retry_count++;
 939   4            }
 940   3            else
 941   3            {
 942   4              break;
 943   4            }
 944   3          }
 945   2      
 946   2          if(u8Status == RETURN_PHY_SUCCESS)
 947   2          {
 948   3            Retry_count = u8LoopNoAck;    
 949   3            break;
 950   3          }
 951   2          else
 952   2          {
 953   3            // Here, NoAck Delay
 954   3          }
 955   2        }
 956   1      
 957   1        return u8Status;
 958   1      }
 959          
 960          ///////////////////////////////////////////////////////////////////////////////////////////////
 961          /// 
 962          ///   Makes a MAC packet and transmits it.
 963          ///
 964          /// @param  ptMacDataReq  : Parameter of the MAC packet to be transmitted.
 965          /// @return UINT8. Status.
 966          /// 
 967          ///////////////////////////////////////////////////////////////////////////////////////////////
 968          UINT8 AppLib_MacDataRequest(tMAC_DATA_REQ* ptMacDataReq)
 969          {
 970   1        UINT8 u8Status;
 971   1        UINT8 u8ResultedPsduLen;
 972   1      
 973   1        u8Status = AppLib_MacDataFrameMake(ptMacDataReq, &xMTxFIFO(1), &u8ResultedPsduLen);
 974   1        if(u8Status == maccSTA_SUCCESS)
 975   1        {
 976   2          xMTxFIFO(0) = u8ResultedPsduLen;
 977   2          u8Status = AppLib_TxFifoTransmit(gtMIB.u8NoAckRetry, gtMIB.u8BackoffRetry);
 978   2        }
 979   1        return u8Status;
 980   1      }
 981          ///////////////////////////////////////////////////////////////////////////////////////////////
 982          /// 
C51 COMPILER V9.53.0.0   UTIL_APP                                                          01/28/2020 11:28:56 PAGE 17  

 983          ///   Delays for 1 micro-seconds.
 984          ///
 985          /// @param  void
 986          /// @return void
 987          /// 
 988          ///////////////////////////////////////////////////////////////////////////////////////////////
 989          void AppLib_DelayFor1us(void)
 990          {
 991   1        _nop_();
 992   1      }
 993          void AppLib_DelayForus(UINT16 SBMilliSecond)
 994          {
 995   1        static  UINT16  u16Count;
 996   1      
 997   1        for(u16Count=0 ; u16Count < SBMilliSecond ; u16Count++)
 998   1        {
 999   2          AppLib_DelayFor2us();
1000   2        } 
1001   1      }
1002          ///////////////////////////////////////////////////////////////////////////////////////////////
1003          /// 
1004          ///   Delays for 2 micro-seconds.
1005          ///
1006          /// @param  void
1007          /// @return void
1008          /// 
1009          ///////////////////////////////////////////////////////////////////////////////////////////////
1010          void AppLib_DelayFor2us(void)
1011          {
1012   1        static  UINT8 ib;
1013   1      
1014   1        for(ib=0 ; ib<1 ; ib++);
1015   1      }
1016          ///////////////////////////////////////////////////////////////////////////////////////////////
1017          /// 
1018          ///   Delays for 10 micro-seconds.
1019          ///
1020          /// @param  void
1021          /// @return void
1022          /// 
1023          ///////////////////////////////////////////////////////////////////////////////////////////////
1024          void AppLib_DelayFor10us(void)
1025          {
1026   1        static  UINT8 ib;
1027   1      
1028   1        for(ib=0 ; ib<9 ; ib++);
1029   1      }
1030          ///////////////////////////////////////////////////////////////////////////////////////////////
1031          /// 
1032          ///   Delays for 50 micro-seconds.
1033          ///
1034          /// @param  void
1035          /// @return void
1036          /// 
1037          ///////////////////////////////////////////////////////////////////////////////////////////////
1038          void AppLib_DelayFor50us(void)
1039          {
1040   1        static  UINT8 ib;
1041   1      
1042   1        for(ib=0 ; ib<48 ; ib++);
1043   1      }
1044          ///////////////////////////////////////////////////////////////////////////////////////////////
C51 COMPILER V9.53.0.0   UTIL_APP                                                          01/28/2020 11:28:56 PAGE 18  

1045          /// 
1046          ///   Delays for 100 micro-seconds.
1047          ///
1048          /// @param  void
1049          /// @return void
1050          /// 
1051          ///////////////////////////////////////////////////////////////////////////////////////////////
1052          void AppLib_DelayFor100us(void)
1053          {
1054   1        static  UINT8 ib;
1055   1      
1056   1        for(ib=0 ; ib<96 ; ib++);
1057   1      }
1058          ///////////////////////////////////////////////////////////////////////////////////////////////
1059          /// 
1060          ///   Delays for 500 micro-seconds.
1061          ///
1062          /// @param  void
1063          /// @return void
1064          /// 
1065          ///////////////////////////////////////////////////////////////////////////////////////////////
1066          void AppLib_DelayFor500us(void)
1067          {
1068   1        static  UINT16  iw;
1069   1      
1070   1        for(iw=0 ; iw<105 ; iw++);
1071   1      }
1072          ///////////////////////////////////////////////////////////////////////////////////////////////
1073          /// 
1074          ///   Delays for 1 milli-seconds.
1075          ///
1076          /// @param  void
1077          /// @return void
1078          /// 
1079          ///////////////////////////////////////////////////////////////////////////////////////////////
1080          void AppLib_DelayFor1ms(void)
1081          {
1082   1        static  UINT16  iw;
1083   1      
1084   1        for(iw=0 ; iw<210 ; iw++);
1085   1      }
1086          
1087          ///////////////////////////////////////////////////////////////////////////////////////////////
1088          /// 
1089          ///   Delays for "u16MilliSecond" milli-seconds.
1090          ///
1091          /// @param  u16MilliSecond  : Number of milli-seconds.
1092          /// @return void
1093          /// 
1094          ///////////////////////////////////////////////////////////////////////////////////////////////
1095          void AppLib_Delay(UINT16 u16MilliSecond)
1096          {
1097   1        static  UINT16  u16Count;
1098   1      
1099   1        for(u16Count=0 ; u16Count < u16MilliSecond ; u16Count++)
1100   1        {
1101   2          AppLib_DelayFor1ms();
1102   2        } 
1103   1      }
1104           
1105          ///////////////////////////////////////////////////////////////////////////////////////////////
1106          /// 
C51 COMPILER V9.53.0.0   UTIL_APP                                                          01/28/2020 11:28:56 PAGE 19  

1107          ///   Displays 8-bit data array.
1108          ///
1109          /// @param  pu8Buff   : Pointer to the first data to be displayed.
1110          /// @param  u16Len    : Length of data to be displayed.
1111          /// @param  u8Linefeed  : The number of data for linefeed.
1112          /// @return void
1113          /// 
1114          ///////////////////////////////////////////////////////////////////////////////////////////////
1115          void Display_Buffer(UINT8* pu8Buff, UINT16 u16Len, UINT8 u8Linefeed)
1116          {
1117   1        UINT16  iw;
1118   1      
1119   1        for(iw=0 ; iw<u16Len ; iw++)
1120   1        { 
1121   2          if(u8Linefeed)
1122   2          {
1123   3            if( (iw % u8Linefeed) == 0)   zPrintf(1, "\n");
1124   3          }
1125   2          zPrintf(1, " %02x",(short)pu8Buff[iw]);
1126   2        }
1127   1      }
1128          
1129          ///////////////////////////////////////////////////////////////////////////////////////////////
1130          /// 
1131          ///   Displays information of a MIB(MAC Information Base).
1132          ///
1133          /// @param  ptMIB : Pointer to the structure variable of MIB.
1134          /// @return void
1135          /// 
1136          ///////////////////////////////////////////////////////////////////////////////////////////////
1137          void Display_MIB(tMAC_INFO_BASE* ptMIB)
1138          {
1139   1        zPrintf(1, "\n");
1140   1        zPrintf(1, "\n [MIB]");
1141   1        zPrintf(1, "\n Chan=%u (%u MHz), ",(short)ptMIB->u8Channel,(2405 + (ptMIB->u8Channel - 11)*5));
1142   1        zPrintf(1, "  PanID=0x%04x",ptMIB->u16PanID);
1143   1        zPrintf(1, "\n ShortAddr=0x%04x",ptMIB->u16ShortAddr);
1144   1        zPrintf(1, " :IEEEAddr(0~7)=0x");
1145   1        Display_Buffer(ptMIB->au8IEEEAddr, 8, 0);
1146   1        zPrintf(1, "\n DstShortAddr=0x%04x",ptMIB->u16DstShortAddr);
1147   1        zPrintf(1, " :DstIEEEAddr(0~7)=0x");
1148   1        Display_Buffer(ptMIB->au8DstIEEEAddr, 8, 0);  
1149   1        zPrintf(1, "\n DataRate=0x%02x, ",(short)ptMIB->u8DataRate);
1150   1        zPrintf(1, " :TxPwrLevel=0x%02x, ",(short)ptMIB->u8TxPowerLevel);
1151   1        zPrintf(1, "  NoAckRetry=%u",(short)ptMIB->u8NoAckRetry);
1152   1        zPrintf(1, " :BackoffRetry=%u",(short)ptMIB->u8BackoffRetry);
1153   1      }
1154          
1155          ///////////////////////////////////////////////////////////////////////////////////////////////
1156          /// 
1157          ///   Displays information of a MAC packet.
1158          ///
1159          /// @param  ptMac : Pointer to the structure variable of MAC packet.
1160          /// @return void
1161          /// 
1162          ///////////////////////////////////////////////////////////////////////////////////////////////
1163          void Display_MacInfo(tMAC_INFO* ptMac)
1164          {
1165   1        zPrintf(1, "\n");
1166   1        zPrintf(1, "\n [RX-MAC-PKT]");
1167   1        zPrintf(1, "\n DSN=0x%02x, OOB=0x%02x",(short)ptMac->u8SeqNum, (short)ptMac->u8OobCode);  
1168   1        zPrintf(1, " :dBm=%d",(short)ptMac->i8RSSI);
C51 COMPILER V9.53.0.0   UTIL_APP                                                          01/28/2020 11:28:56 PAGE 20  

1169   1        zPrintf(1, " :Corr=%d",(short)ptMac->u8Correlation);
1170   1        zPrintf(1, "\n Dst. Mode=%02x",(short)ptMac->uFC_H.bBit.u8DstMode);
1171   1        if(ptMac->uFC_H.bBit.u8DstMode == 2)
1172   1        {
1173   2          zPrintf(1, " :PanID=0x%04x",ptMac->u16DstPanID);
1174   2          zPrintf(1, " :ShortAddr=0x%04x",ptMac->uDstAddr.u16Short);
1175   2        }
1176   1        else if(ptMac->uFC_H.bBit.u8DstMode == 3)
1177   1        {
1178   2          zPrintf(1, " :PanID=0x%04x",ptMac->u16DstPanID);
1179   2          zPrintf(1, " :IEEE(0~7)=0x");
1180   2          Display_Buffer(ptMac->uDstAddr.au8Ext, 8, 0);
1181   2        }
1182   1        zPrintf(1, "\n Src. Mode=%02x",(short)ptMac->uFC_H.bBit.u8SrcMode);
1183   1        if(ptMac->uFC_H.bBit.u8SrcMode == 2)
1184   1        {
1185   2          zPrintf(1, " :PanID=0x%04x",ptMac->u16SrcPanID);
1186   2          zPrintf(1, " :ShortAddr=0x%04x",ptMac->uSrcAddr.u16Short);
1187   2        }
1188   1        else if(ptMac->uFC_H.bBit.u8SrcMode == 3)
1189   1        {
1190   2          zPrintf(1, " :PanID=0x%04x",ptMac->u16SrcPanID);
1191   2          zPrintf(1, " :IEEE(0~7)=0x");
1192   2          Display_Buffer(ptMac->uSrcAddr.au8Ext, 8, 0);
1193   2        }
1194   1        zPrintf(1, "\n MSDU Len=%02u : ",(short)ptMac->u8MacPayLen);  
1195   1        zPrintf(1, " :MSDU =");
1196   1        Display_Buffer(ptMac->pu8MacPayload, ptMac->u8MacPayLen, 16);
1197   1      }
1198          
1199          ///////////////////////////////////////////////////////////////////////////////////////////////
1200          /// 
1201          ///   Displays information of a HIB(Hardware Information Base).
1202          ///
1203          /// @param  ptMIB : Pointer to the structure variable of HIB.
1204          /// @return void
1205          /// 
1206          ///////////////////////////////////////////////////////////////////////////////////////////////
1207          void Display_HIB(tHW_INFORMATION* ptHIB)
1208          {
1209   1        zPrintf(1, "\n");
1210   1        zPrintf(1, "\n === HIB Display ===");
1211   1        zPrintf(1, "\n IEEE ADDR(LSB~MSB) :");  
1212   1        Display_Buffer(ptHIB->au8IEEEAddr, 8, 0);
1213   1        zPrintf(1, "\n ChipIndex = 0x%02x",(short)ptHIB->u8ChipID);
1214   1        if(ptHIB->u8ChipID == 1)      {zPrintf(1, " (MG2400)");}
1215   1        else if(ptHIB->u8ChipID == 2)   {zPrintf(1, " (MG245X)");}
1216   1        else if(ptHIB->u8ChipID == 3)   {zPrintf(1, " (MG2470)");}
1217   1        else if(ptHIB->u8ChipID == 4)   {zPrintf(1, " (MG2460)");}
1218   1        else if(ptHIB->u8ChipID == 0x80)  {zPrintf(1, " (MG2410)");}  // STM32F
1219   1        else                {zPrintf(1, " (Unclassified)");}
1220   1        zPrintf(1, "\n Channel   = %u (%u MHz)",(short)ptHIB->u8Channel,(2405 + (ptHIB->u8Channel - 11)*5));
1221   1        zPrintf(1, "\n StackID   = 0x%02x",(short)ptHIB->u8StackID);
1222   1        zPrintf(1, "\n TxPower   = 0x%02x",(short)ptHIB->u8TxPower);
1223   1        zPrintf(1, "    DataRate  = 0x%02x",(short)ptHIB->u8DataRate);
1224   1        zPrintf(1, "\n PanID     = 0x%02x%02x",(short)ptHIB->au8PanID[1], (short)ptHIB->au8PanID[0]);
1225   1        zPrintf(1, "  NwkAddr  = 0x%02x%02x",(short)ptHIB->au8NwkAddr[1], (short)ptHIB->au8NwkAddr[0]);
1226   1        zPrintf(1, "\n SecLevel  = 0x%02x",(short)ptHIB->u8SecurityLevel);
1227   1        zPrintf(1, "    PreConfig = 0x%02x",(short)ptHIB->u8PreConfigMode);
1228   1        zPrintf(1, "\n NWK Key (LSB~MSB) :");
1229   1        Display_Buffer(ptHIB->au8NwkKey, 16, 0);
1230   1        zPrintf(1, "\n Reserv_0(LSB~MSB) :");
C51 COMPILER V9.53.0.0   UTIL_APP                                                          01/28/2020 11:28:56 PAGE 21  

1231   1        Display_Buffer(ptHIB->au8Reserved_0, 8, 0);
1232   1        zPrintf(1, "\n EPID    (LSB~MSB) :");
1233   1        Display_Buffer(ptHIB->au8EPID, 8, 0);
1234   1        zPrintf(1, "\n Reserv_1(LSB~MSB) :");
1235   1        Display_Buffer(ptHIB->au8Reserved_1, 8, 0);
1236   1        zPrintf(1, "\n GeneralWord0 = 0x%02x%02x",(short)ptHIB->au8GeneralWord0[1],(short)ptHIB->au8GeneralWord0[
             -0]);
1237   1        zPrintf(1, "\n GeneralWord1 = 0x%02x%02x",(short)ptHIB->au8GeneralWord1[1],(short)ptHIB->au8GeneralWord1[
             -0]);
1238   1        //zPrintf(1, "\n SUM = 0x%02x",(short)ptHIB->CSUM);
1239   1      }
1240          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4499    ----
   CONSTANT SIZE    =   1004    ----
   XDATA SIZE       =     52     199
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
