C51 COMPILER V9.53.0.0   IB_MAIN_SEN                                                       01/28/2020 11:28:56 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE IB_MAIN_SEN
OBJECT MODULE PLACED IN .\HEX\ib_main_sen.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Sample\EVB\ib_main_sen.c LARGE OPTIMIZE(9,SIZE) BROWSE INCDIR(.\Platform
                    -\Include\;.\Platform\hal\;.\Sample\Include\;.\Sample\Utility\;.\Sample\EVB) DEFINE(__DEBUG,__INTERNAL_MODE) PRINT(.\LST\
                    -ib_main_sen.lst) TABS(2) OBJECT(.\HEX\ib_main_sen.obj)

line level    source

   1          
   2          /*******************************************************************************
   3            - Chip    : MG2470B
   4            - Vendor    : RadioPulse Inc, 2011.
   5            - Date    : 2014-08-28
   6            - Version   : V2.6
   7          
   8          //----------------------------------------------------------------------------------------------
   9          // DIP Sw  0 = 11 ch
  10          
  11          // !!!!!!!!! ID ·Î »ç¿ë 1 ~ 60 ¾Æ´Ï¸é µ¿ÀÛ ¾ÈÇÔ  !!!!!!!!!!!!!!!!!!
  12          // - source IEEE address ¸¶Áö¸· ¹ÙÀÌÆ®¸¦ ID ·Î »ç¿ë 1 ~ 60
  13          //---------------------------------------------------------------------------------------------- <= old ve
             -rsion : ÀÚµ¿ Æä¾î¸µ ÀÌÀü ¹öÀü
  14          
  15          -  USE_PAIRING_CODE = 0 ÀÏ¶§
  16             : ´Ù¿î·Îµå½Ã IEEE¸¦ ÇÏÀ§ 1¹ÙÀÌÆ® Á¦¿Ü ÇÏ°í Á¤ÇØÁø °ªÀ¸·Î ´Ù¿î·Îµå ÇØ¾ßµÊ
  17          
  18          -  Router »ç¿ë½Ã
  19             : channel DIP sw : router or coordi¿Í °°Àº °ªÀ¸·Î ¼³Á¤(router ¸ðµå »ç¿ë½Ã 2º¸´Ù Å©°Å³ª °°Àº°ªÀ¸·Î ¼³Á¤ 
             -ÇØ¾ßµÊ, °¡´ÉÇÑ ch 26 »ç¿ë Åä·Ï)
  20           //----------------------------------------------------------------------------------------------
  21          
  22          [2019-04-09] V01.6  :  ÇÏµ¿ ¹ßÀü¼Ò Àû¿ë ¿Âµµ ¼¾¼­ NO Avg ¹öÀü 
  23          [2018-10-22] V01.5Z  :  ÇÏµ¿ Å»È² - Á¦³Ê º¸µå Àü·ù µ¥ÀÌÅ¸  ¼öÁ¤ 
  24          [2018-09-27] V01.5  :  µ¿ÇØ Incomming  Release - Tehrmistor (No  Á¦³Êº¸µå)
  25            - Á¦³Ê remark, Thermistor ON   
  26          [2018-06-19] V01.5  :  ÇÏµ¿ 3Â÷ ³³Ç°  ÃÖÁ¾ Release
  27            - ZENER_BOARD  0  : »ç¿ë ÇØÁ¦  
  28          [2018-04-03] V01.5T  :  Á¦³Ê º¸µå  overcurretn wakeup 
  29            - ¿Âµµ ¼¾¼­ data packet¿¡ °úÀü·ù µ¥ÀÌÅ¸¸¦ ½Ç¾î Àü¼Û ÇÏµµ·Ï   
  30          [2018-03-05] V01.5 :  Low VCC Ã³¸® Flag Ã³¸®   
  31          [2018-01-22] V01.5 :  ³»ºÎ¿Âµµ¼¾¼­¿ë ÄÄÆÄÀÏ  Release  ¿¹Á¤   
  32            - DIP switch µ¿ÀÛ ¸ðµå º¯°æ  
  33          [2017-12-14] V01.5 : ¿Âµµ ¼¾¼­ NTC ½á¹Ì½ºÅÍ »ç¿ë   
  34          [2017-10-18] V01.4  :
  35            - LEDProcess()
  36          [2017-10-16] V01.4 : vcc low Ã³¸®  
  37          [2017-09-07] V01.3 : µ¿ÇØ 3Â÷ Release
  38            -  Áøµ¿ ¼¾¼­°¡ 0, 0, 0 ÀÏ °æ¿ì ¼Û½ÅÀ» ÇÏÁö ¾Êµµ·Ï
  39                  -  wakeup mode ¼Û½ÅÁÖ±â 10 -> 5ÃÊ
  40          [2017-09-04] V01.3 : ¿Âµµ¼¼¼­ ¿À·ù ¼öÁ¤
  41          [2017-08-07] V01.2 : ÄÄÆÄÀÏ Release - ¼¼ºÎ, ¾Èµ¿, ÅÂ¾È, ¼¼Á¾    
  42          [2017-07-18] V01.10  :  ¼¾¼­ µ¥ÀÌÅ¸ read ÁÖ±â¸¦ µ¿ÀÛ ¸ðµå¿¡ °ü°è ¾øÀÌ ¸ðµÎ ¶È°°ÀÌ
  43          [2017-07-14] V01.10  :  ¿Âµµ ¼¾¼­ while ¹® Á¦°Å   
  44          [2017-07-10] V01.10 -  ÄÚµå °³¼±   :  sleep mode ¿©ºÎ¸¦ dip switch ¸¦ »ç¿ë ÇÏ¿© °áÁ¤ ÇÏµµ·Ï 
  45          [2017-06-13] V01.10 -  ¼¼ºÎ¿ë  Release 
  46          [2017-06-09] V01.10 -  ¼¼ºÎ¿ëÀ¸·Î ¹öÀü º¯°æ    
  47          [2017-06-08] V01.09 -  µð¹ö±ë °³¼± ÀÛ¾÷ ÄÚµå
  48          [2017-05-08] V01.09 -  º¸·É  Release
  49          [2017-03-23] V01.08 - µ¿ÇØ¿ëÀ¸·Î ´Ù½Ã ÄÄÆÄÀÏ ÁøÇà   
  50          [2017-02-22] V01.08 - SleepMode II  code  ±â¹ÝÀ¸·Î 1.06  hisotry copy   
  51          [2016-12-09] V01.06 :  ¼¾¼­ ¿É¼Ç ¸í·É ¼ö½Å Ã³¸®
C51 COMPILER V9.53.0.0   IB_MAIN_SEN                                                       01/28/2020 11:28:56 PAGE 2   

  52          [2016-11-04] V01.05  :  Multi comm test routine ¾÷µ¥ÀÌÆ®
  53          [2016-11-01] V01.05 : ¼¾¼­ ÃÖ´ë 60 -> 125 °³ ±îÁö °¡´É ÇÏµµ·Ï
  54          [2016-10-18] V01.04 :  ÆÄÀÏ ºÐÇÒ Á¤¸®
  55          [2016-10-07] V01.03 :  ÇÏµ¿ 1Â÷ ¼³Ä¡ÈÄ ¹öÀü¾÷
  56          [2016-09-06] V01.02 :-Æä¾î ¹öÅÏ µ¿ÀÛ ¹ö±× ¼öÁ¤ 
  57          [2016-08-24] V01.02 :  Æä¾î¸µ ¹öÆ° ±â´É Ãß°¡
  58          [2016-08-11] V01.02 :  Àû¿Ü¼­ ¿Âµµ¼¾¼­ µ¥ÀÌÅ¸ Ã³¸® °¡´ÉÅä·Ï  
  59          [2016-08-08] V01.02 :  PER test ·çÆ¾ 
  60          [2016-07-20] V01.02 :  ÀÚµ¿ Æä¾î¸µ ±â´É Ãß°¡  
  61          *******************************************************************************/
  62          
  63          
  64          #include "ib_main_sen.h"
  65          
  66          
  67          UINT8   Porduct_Mode = 0;
  68          UINT16  gTestCount = 0;
  69          
  70          // powerdown mode conatant  °ªÀÌ default   
  71          // UINT8 u8_TEMP_SEN_R_TIME = TEMP_SEN_R_TIME_PD;
  72          //UINT8 u8_ACCEL_CURR_SEN_R_TIME = ACCEL_CURR_SEN_R_TIME_PD;
  73          UINT8   u8_SLEEP_TIME = POWER_DOWN_TIME;  
  74          UINT8   u8_SLEEP_TIME_Prev; 
  75          
  76          UINT16  u16_TX_TIME = TX_TIME - SEN_READ_TIME;      // ±âº» ÁÖ±â 1sec·Î Ç×»ó °íÁ¤ : Á¤È®È÷ ÇÏ·Á¸é  => TIME_1S
             -EC - SEN_READ_TIME
  77          
  78          
  79          //UINT8 COORDI_IEEE_ADDRESS[8] = {0x00, 0x15, 0x51, 0x01, 0x00, 0x01, 0xFF, 0xF8};
  80          //UINT8 ROUTER_IEEE_ADDRESS[8] = {0x00, 0x15, 0x51, 0x01, 0x00, 0x01, 0xFF, 0xF0};
  81          UINT8 COORDI_IEEE_ADDRESS[8] = {0x00, 0x00, 0xFF, 0xF8, 0x01, 0x51, 0x15, 0x00};
  82          //UINT8 ROUTER_IEEE_ADDRESS[8] = {0x00, 0x01, 0x01, 0x00, 0x01, 0x51, 0x15, 0x00};
  83          
  84          #include "ISR.c"
  85          
  86          UINT8 code gcau8BufferFlash[512]  _at_ CODE_ADDRESS_USER0;
  87          UINT8 code gcau8BufferFlash1[512] _at_ CODE_ADDRESS_USER1;
  88          UINT8 code gcau8BufferFlash2[512] _at_ CODE_ADDRESS_USER2;
  89          
  90          // mem ÇÒ´ç¿¡ ¿©À¯°¡ ¾øÀ¸¸é data °¡ Á¤»ó ÀûÀ¸·Î ÀúÀå µÇÁö ¸øÇÔ, ÀÌ»óµ¿ÀÛÇÔ ( ÇöÀç´Â +6 ¸¸Å­ ¿©À¯¸¦°¡Á®°¨)
  91          xdata UINT16 malloc_mem[AVG_CURR_BUFF_SIZE + AVG_TEMP_BUFF_SIZE + 6]; 
  92          
  93            
  94          void  Init_ExtAmp(void)
  95          {
  96   1        
  97   1        //----------------------------------------------------------------------------------------
  98   1        //  Enable GPIO to control External Amplifier
  99   1        // TODO: If a external amplifier is used, GPOIs for that should be set.
 100   1      #if (_OPTION_EXT_AMP_CONTROL == 2)
                zPrintf(1, "\n");
                zPrintf(1, "\n >> External Amplifier Control Signals are enabled.");
                zPrintf(1, "\n >> GPIO 1.7 is TRSW. (TX=High, RX=Low)");
                zPrintf(1, "\n >> GPIO 1.6 is nTRSW. (TX=Low, RX=High)");
                zPrintf(1, "\n");
                HAL_AmpCtrlGpio1Set(1);
              #elif (_OPTION_EXT_AMP_CONTROL == 1)
                zPrintf(1, "\n");
                zPrintf(1, "\n >> External Amplifier Control Signals are enabled.");
                zPrintf(1, "\n >> GPIO 3.7 is TRSW. (TX=High, RX=Low)");
                zPrintf(1, "\n >> GPIO 3.6 is nTRSW. (TX=Low, RX=High)");
                zPrintf(1, "\n");
C51 COMPILER V9.53.0.0   IB_MAIN_SEN                                                       01/28/2020 11:28:56 PAGE 3   

                HAL_AmpCtrlSignalSet(1, 0);
              #else
 115   1        /*
 116   1        //  Booting Message 
 117   1        zPrintf(1, "\n");
 118   1        zPrintf(1, "\n >> No External Amplifier");
 119   1        */  
 120   1      #endif
 121   1        //----------------------------------------------------------------------------------------
 122   1      }
 123          
 124          
 125          void Init_SysConfig(void)
 126          {
 127   1        //  UART1 : Turn on the clock and Set
 128   1        #if _UARTDEBUG_MODE
                HAL_Uart1ClockOn(ON);
                HAL_Uart1IntSet(ENABLE, PRIORITY_LOW, 115200, UART_MODE_8N1);
                #endif
 132   1      
 133   1        //  Interrupt Enable
 134   1        HAL_SystemIntSet(ENABLE);     // EA=1
 135   1      
 136   1        #if _UARTDEBUG_MODE
                zPrintf(1, "\n\r>> Reset Init..\n");
                #endif
 139   1      
 140   1        // Kong - Áøµ¿¼¾¼­¿ë I2C Init --> Turn on the clock and Set
 141   1        #if _ACCEL_USE
                  #if _UARTDEBUG_MODE
                  zPrintf(1, "I2C Init..\n");
                  #endif
                  HAL_I2CClockOn(1);
                  HAL_I2CIntSet(1,1,1,28);//20  
                #endif
 148   1      
 149   1        //  TIMER0 : Turn on the clock and Set
 150   1        #if _TIMER0_USE
                  #if _UARTDEBUG_MODE
                  zPrintf(1, "TIMER0 Init..\n");
                  #endif
                  HAL_Timer0ClockOn(ON);
                  HAL_Timer0IntSet(ENABLE, PRIORITY_LOW, RUN, 2);     // Enable TIMER0 Interrupt
                #endif
 157   1        
 158   1        //  GPIO : Turn on the clock and Set
 159   1        // TODO: Set GPIOs to be used if needed.  
 160   1        HAL_GpioClockOn(ON);
 161   1        
 162   1        // DIP switch MSB  : SLEEP_MODE_PIN  = 0(ON) : sleep mode 
 163   1        //HAL_Gpio0InOutSet(0, GPIO_INPUT, GPIO_PULL_UP );    //--- Kong Current Down
 164   1        AppLib_DelayFor1us();
 165   1        
 166   1        // org
 167   1        //HAL_Gpio0InOutSet(1, GPIO_OUTPUT, GPIO_DRIVE_4mA);  GP01 = 0; // pen id 4  : 0x1F ±îÁö 
 168   1        // WAKEUP_TX_PERIOD ÇÉÀ¸·Î »ç¿ë 
 169   1        #if (_USE_DIPSWITCH==1)
                HAL_Gpio0InOutSet(1, GPIO_INPUT, GPIO_PULL_UP); 
                HAL_Gpio0InOutSet(2, GPIO_OUTPUT, GPIO_DRIVE_4mA);  GP02 = 0;
                HAL_Gpio0InOutSet(3, GPIO_OUTPUT, GPIO_DRIVE_4mA);  GP03 = 0;
                HAL_Gpio0InOutSet(4, GPIO_OUTPUT, GPIO_DRIVE_4mA);  GP04 = 0; 
                HAL_Gpio0InOutSet(5, GPIO_OUTPUT, GPIO_DRIVE_4mA);  GP05 = 0; // pen id 0  
C51 COMPILER V9.53.0.0   IB_MAIN_SEN                                                       01/28/2020 11:28:56 PAGE 4   

                HAL_Gpio0InOutSet(6, GPIO_OUTPUT, GPIO_DRIVE_4mA);  GP06 = 0; // ch 3  
                HAL_Gpio0InOutSet(7, GPIO_OUTPUT, GPIO_DRIVE_4mA);  GP07 = 0;
                HAL_Gpio3InOutSet(3, GPIO_OUTPUT, GPIO_DRIVE_4mA);  GP33 = 0;   
                HAL_Gpio3InOutSet(4, GPIO_OUTPUT, GPIO_DRIVE_4mA);  GP34 = 0; // ch 0  
                #endif
 180   1      
 181   1        #if (_EPAS_MODE == 1)
 182   1        HAL_Gpio0InOutSet(0, GPIO_INPUT, GPIO_PULL_UP);         // 0À¸·Î ÀÎÁö½Ã ¼¾¼­ TEST MODE·Î µ¿ÀÛµÊ. ÁÖÀÇ ¿ä¸Á..
 183   1        HAL_Gpio0InOutSet(1, GPIO_INPUT, GPIO_PULL_UP);
 184   1        HAL_Gpio0InOutSet(2, GPIO_INPUT, GPIO_PULL_UP);
 185   1        HAL_Gpio0InOutSet(3, GPIO_INPUT, GPIO_PULL_UP);
 186   1        HAL_Gpio0InOutSet(4, GPIO_INPUT, GPIO_PULL_UP);
 187   1        HAL_Gpio0InOutSet(5, GPIO_INPUT, GPIO_PULL_UP);
 188   1        HAL_Gpio0InOutSet(6, GPIO_INPUT, GPIO_PULL_UP);
 189   1        HAL_Gpio0InOutSet(7, GPIO_INPUT, GPIO_PULL_UP);
 190   1      
 191   1        // P1.0 : booting ½Ã µð¹ö±× ¸ðµå Ã¼Å© input pinÀ¸·Î »ç¿ë
 192   1        HAL_Gpio1InOutSet(0, GPIO_INPUT, GPIO_PULL_UP);   //UART_RXD1 : UART_DBG_MODE_PIN  
 193   1        //HAL_Gpio1InOutSet(3, GPIO_INPUT, GPIO_PULL_UP); 
 194   1        HAL_Gpio1InOutSet(3, GPIO_OUTPUT, GPIO_DRIVE_4mA);  ACCELSEN_RESET = 0; //TP5 
 195   1        HAL_Gpio1InOutSet(4, GPIO_INPUT, GPIO_PULL_UP);
 196   1        HAL_Gpio1InOutSet(6, GPIO_INPUT, GPIO_PULL_UP);
 197   1        HAL_Gpio1InOutSet(7, GPIO_INPUT, GPIO_PULL_UP);
 198   1      
 199   1        HAL_Gpio3InOutSet(0, GPIO_INPUT, GPIO_PULL_UP);
 200   1        HAL_Gpio3InOutSet(1, GPIO_INPUT, GPIO_PULL_UP);
 201   1        HAL_Gpio3InOutSet(2, GPIO_INPUT, GPIO_PULL_UP);
 202   1        HAL_Gpio3InOutSet(3, GPIO_INPUT, GPIO_PULL_UP);
 203   1        HAL_Gpio3InOutSet(4, GPIO_INPUT, GPIO_PULL_UP);
 204   1        HAL_Gpio3InOutSet(5, GPIO_OUTPUT, GPIO_DRIVE_4mA);  NTC_CONNECT = 0;    // NTC Thermostor Ref Line GND Conne
             -ction..
 205   1        HAL_Gpio3InOutSet(6, GPIO_INPUT, GPIO_PULL_UP);
 206   1        HAL_Gpio3InOutSet(7, GPIO_INPUT, GPIO_PULL_UP);
 207   1      
 208   1        // P1.0 : booting ½Ã µð¹ö±× ¸ðµå Ã¼Å© input pinÀ¸·Î »ç¿ë
 209   1        //HAL_Gpio1InOutSet(0, GPIO_INPUT, GPIO_PULL_UP);   //UART_RXD1 : UART_DBG_MODE_PIN  
 210   1        //HAL_Gpio1InOutSet(3, GPIO_OUTPUT, GPIO_DRIVE_4mA);  ACCELSEN_RESET = RST_OFF; //TP5 
 211   1        //HAL_Gpio1InOutSet(4, GPIO_INPUT, GPIO_PULL_UP);   PAIRING_BUTTON = BTN_OFF; // TP4
 212   1      
 213   1        #elif (_EPAS_MODE == 0)
                HAL_Gpio3InOutSet(6, GPIO_OUTPUT, GPIO_DRIVE_4mA);  BLUE_LED = LED_OFF; //BLUE LED OFF
                HAL_Gpio3InOutSet(7, GPIO_OUTPUT, GPIO_DRIVE_4mA);  RED_LED = LED_OFF;  //RED  LED OFF
                #endif
 217   1        
 218   1        #if (TEMP_SEN_MODE == THERM_SEN)  
 219   1        //HAL_Gpio3InOutSet(0, GPIO_INPUT, GPIO_PULL_UP);     // Thermistor »ç¿ë ½Ã ±âÁ¸ ÇÉ(TEMP_OUT)À» inputÀ¸·Î ¼
             -³Á¤   Kong.sh ÁÖ¼® 191225
 220   1        #endif
 221   1      
 222   1        //HAL_Gpio3InOutSet(2, GPIO_INPUT, GPIO_PULL_UP);   // OVER_CURRENT_CHECK Kong.sh ÁÖ¼® 191225
 223   1        AppLib_DelayFor1us();
 224   1        
 225   1        //HAL_Gpio3InOutSet(5, GPIO_OUTPUT, GPIO_DRIVE_4mA);  GP35 = 0;   // Kong.sh ÁÖ¼® 191225
 226   1        
 227   1        // P1.0 : booting ½Ã µð¹ö±× ¸ðµå Ã¼Å© input pinÀ¸·Î »ç¿ë
 228   1        //HAL_Gpio1InOutSet(0, GPIO_INPUT, GPIO_PULL_UP);   //UART_RXD1 : UART_DBG_MODE_PIN  
 229   1        //HAL_Gpio1InOutSet(3, GPIO_OUTPUT, GPIO_DRIVE_4mA);  ACCELSEN_RESET = RST_OFF; //TP5 
 230   1        //HAL_Gpio1InOutSet(4, GPIO_INPUT, GPIO_PULL_UP);   PAIRING_BUTTON = BTN_OFF; // TP4
 231   1      
 232   1        if(xCHIPID == 0x70)
 233   1        {
 234   2          zPrintf(1, "\n Failed. This software only supports CHIP ID over 0x70 !!!");
C51 COMPILER V9.53.0.0   IB_MAIN_SEN                                                       01/28/2020 11:28:56 PAGE 5   

 235   2          while(SYS_Uart1TxWorking());
 236   2          SYS_WdtReset(0);
 237   2        }
 238   1      }
 239          
 240          void Init_RF_HAL(void)
 241          {
 242   1        // sleep mode ¿¡¼­´Â waiting ÈÄ µ¿ÀÛ Àü¿¡ RF ¸¦ ÄÑµµ·Ï µÇ¾î ÀÖÀ½ : sleep mode °¡ ¾Æ´Ï°Å³ª Å×½ºÆ®½Ã RF¸¦ ¹
             -Ì¸®  ÄÑµµ·Ï
 243   1        #if 0
                if ( (_POWERDOWN_USE==0) || (_IS_NO_SLEEP_MODE)  || (gtPIB.uPairCount == 0) ) {   //  normal mode ÀÌ¸é ÃÊ±
             -â waiting time ÀÌÈÄ rf ON  
                  // sleep mode  :  no pairing  ¶Ç´Â degug mode   =>  RF ON 
              //    RED_LED = LED_ON;     //RED  LED ON : pair OK
                  zPrintf(1,"Init RF HAL..\n"
              );
                  Init_SetHAL();
                  Init_ExtAmp();    
                }
                #endif
 253   1      
 254   1        #if 1
 255   1        if ( (_IS_NO_SLEEP_MODE)  || (gtPIB.uPairCount == 0) ) {    //  normal mode ÀÌ¸é ÃÊ±â waiting time ÀÌÈÄ rf 
             -ON  
 256   2          // sleep mode  :  no pairing  ¶Ç´Â degug mode   =>  RF ON 
 257   2      //    RED_LED = LED_ON;     //RED  LED ON : pair OK
 258   2          zPrintf(1,"Init RF HAL..\n"
 259   2      );
 260   2          Init_SetHAL();
 261   2          Init_ExtAmp();    
 262   2        }
 263   1        #endif
 264   1      } 
 265          
 266          
 267          
 268          void Init_HAL_Modem(void)
 269          {   
 270   1        HAL_ModemInit(0);
 271   1      
 272   1        if(HAL_ModemOn(10000, 1))
 273   1        {
 274   2          zPrintf(1, "HAL_Modem Reset...\n");
 275   2          SYS_WdtReset(0);
 276   2        }
 277   1        else
 278   1        {
 279   2          #if _UARTDEBUG_MODE
                  zPrintf(1, "HAL_ModemOn => OK\n");
                  #endif
 282   2        }
 283   1        
 284   1        HAL_ModemPost();
 285   1      
 286   1      
 287   1        #if _EPAS_MODE
 288   1        //HAL_RFAnalogSleep(POWER_RF_SLEEP_ADC_ON); // RF Sleep.. 
 289   1        #endif
 290   1      }
 291            
 292            
 293            
C51 COMPILER V9.53.0.0   IB_MAIN_SEN                                                       01/28/2020 11:28:56 PAGE 6   

 294          void Init_SetHAL(void)
 295          {
 296   1        UINT8 u8Status;
 297   1          
 298   1        //----------------------------------------------------------------------------------------
 299   1        // Set HAL value
 300   1        //Configure Network Parameters
 301   1        u8Status = HAL_ChannelSet(gtMIB.u8Channel);
 302   1        if(u8Status)
 303   1        {
 304   2          zPrintf(1, "\n >> Channel Set Failed (%02x)",(short)u8Status);
 305   2        }
 306   1        
 307   1        HAL_PanIDSet(gtMIB.u16PanID);
 308   1        HAL_ShortAddrSet(gtMIB.u16ShortAddr);
 309   1        HAL_TxPowerSet(gtMIB.u8TxPowerLevel);
 310   1        HAL_DataRateSet(gtMIB.u8DataRate);
 311   1        HAL_IEEEAddrSet(gtMIB.au8IEEEAddr); // source IEEE addr
 312   1      
 313   1      #if (_OPTION_MULTI_DATA_RATE)
                HAL_MultiDataRateSet(ON);
              #endif
 316   1      
 317   1        // Initialize Hardware MAC
 318   1        HAL_MacInit();
 319   1      
 320   1        // Initialize RF blocks and enable PHY interrupt. 
 321   1        HAL_RxEnable(OFF);
 322   1        HAL_PhyIntSet(ENABLE, PRIORITY_HIGH);
 323   1        HAL_RxEnable(ON);
 324   1        //----------------------------------------------------------------------------------------
 325   1      }
 326          
 327          
 328          //--------------------------------------------------------------------------------------------
 329          // ÇöÀç HIB data ³ª u8DeviceMode ¸¦ ÃßÈÄ È°¿ë  »ç¿ë °ËÅä
 330          //--------------------------------------------------------------------------------------------
 331          void Init_HIB(void)
 332          {
 333   1        UINT8       u8DeviceMode, iw;
 334   1        UINT8       u8KeyIn;
 335   1      
 336   1        tHW_INFORMATION   tDataHIB;
 337   1      
 338   1      
 339   1        // TODO: Here, MIB parameter can be modified, especially using HIB.
 340   1        // Set HIB Information to MIB.
 341   1        if(SYS_HIBCopy((UINT8 *)&tDataHIB))     // HIB_ADDRESS(0x1000) ¿¡ ÀúÀå µÇ¾î ÀÖ´Â µ¥ÀÌÅ¸¸¦ tDataHIB ¹öÆÛ¿¡ °
             -¡Á®¿È)
 342   1        {                   // gtMIB ¿¡ °ªÀ» set
 343   2          gtMIB.u8Channel = tDataHIB.u8Channel;
 344   2          gtMIB.u16PanID = (tDataHIB.au8PanID[1] << 8) | tDataHIB.au8PanID[0];
 345   2          gtMIB.u16DstPanID = gtMIB.u16PanID;
 346   2          
 347   2          rpmemcpy(gtMIB.au8IEEEAddr, tDataHIB.au8IEEEAddr, 8);
 348   2          // src short addr copy
 349   2          //gtMIB.u16ShortAddr = (tDataHIB.au8NwkAddr[1] << 8) | tDataHIB.au8NwkAddr[0];
 350   2          gtMIB.u16ShortAddr = tDataHIB.au8IEEEAddr[1];
 351   2          gtMIB.u16ShortAddr = gtMIB.u16ShortAddr << 8 | tDataHIB.au8IEEEAddr[0];
 352   2          
 353   2          
 354   2          gtMIB.u8DataRate = tDataHIB.u8DataRate;
C51 COMPILER V9.53.0.0   IB_MAIN_SEN                                                       01/28/2020 11:28:56 PAGE 7   

 355   2          gtMIB.u16DstShortAddr = (tDataHIB.au8GeneralWord0[1] << 8) | tDataHIB.au8GeneralWord0[0];
 356   2          
 357   2          
 358   2          rpmemcpy(gtMIB.au8DstIEEEAddr, tDataHIB.au8Reserved_0, 8);
 359   2      
 360   2          #if _UARTDEBUG_MODE
                    zPrintf(1,"gtMIB.u8Channel : %u\n", (short)gtMIB.u8Channel);
                    zPrintf(1,"gtMIB.u16PanID : 0x%04x\n", (short)gtMIB.u16PanID);
                    zPrintf(1,"gtMIB.u16DstPanID : 0x%04x\n", (short)gtMIB.u16DstPanID);
                    zPrintf(1,"gtMIB.au8IEEEAddr : 0x%02x%02x%02x%02x%02x%02x%02x%02x\n", (short)gtMIB.au8IEEEAddr[7],(shor
             -t)gtMIB.au8IEEEAddr[6],(short)gtMIB.au8IEEEAddr[5],(short)gtMIB.au8IEEEAddr[4],(short)gtMIB.au8IEEEAddr[3],(short)gtMIB.
             -au8IEEEAddr[2],(short)gtMIB.au8IEEEAddr[1],(short)gtMIB.au8IEEEAddr[0]);
                    zPrintf(1,"gtMIB.u16ShortAddr : 0x%04x\n", (short)gtMIB.u16ShortAddr);
                    zPrintf(1,"gtMIB.u8DataRate : %u\n", (short)gtMIB.u8DataRate);
                  #endif
 368   2        }
 369   1        
 370   1        //----------------------------------------------------------------------------------------------
 371   1        // When HIB is invalid, Network Parameters are selected by keyboard input.
 372   1        //----------------------------------------------------------------------------------------------
 373   1        else
 374   1        {
 375   2          
 376   2          zPrintf(1, "\n >> HIB Copy FAIL !!!");
 377   2          zPrintf(1, "\n #########################################");
 378   2          zPrintf(1, "\n >> 0 : PER Transmitter");
 379   2          zPrintf(1, "\n >> 1 : PER Receiver");
 380   2          zPrintf(1, "\n #########################################");
 381   2          zPrintf(1, "\n >> Select Device Mode (within 5 seconds) : ");
 382   2          
 383   2          //----------------------------------------------------------------------------------------
 384   2          // ÇöÀç »ç¿ë ÇÏ°í ÀÖÁö ¾ÊÀ½, ÃßÈÄ È°¿ë °ËÅä
 385   2          //----------------------------------------------------------------------------------------
 386   2          
 387   2          // Wait for 5 seconds. If no key input, Device Mode is 0.
 388   2          // 5ÃÊ ±â´Ù¸°ÈÄ PER test mode µ¿ÀÛ µÇµµ·Ï
 389   2          u8DeviceMode = '0';
 390   2          
 391   2          AppLib_VirtualTimerSet(0, 5000);
 392   2          while(AppLib_VirtualTimerGet(0))
 393   2          {
 394   3            #if !_EPAS_MODE
                    SYS_WdtSet(3000);
                    #endif
 397   3            if(SYS_Uart1Get(&u8KeyIn))
 398   3            {
 399   4              if(u8KeyIn == '1')
 400   4              {
 401   5                u8DeviceMode = '1';
 402   5              }
 403   4              break;
 404   4            }
 405   3          }
 406   2          
 407   2          SYS_Uart1Put(u8DeviceMode);
 408   2      
 409   2          // u8DeviceMode¿¡ µû¶ó ¹Ì¸® ÁöÁ¤µÈ default MIB °ªÀ» load 
 410   2          if(u8DeviceMode == '0')
 411   2          {
 412   3            gtMIB.u8Channel = INIT_CHANNEL;       // INIT_CHANNEL : 0x1A
 413   3            gtMIB.u16PanID = INIT_PAN_ID;       // INIT_PAN_ID : 0x2470
 414   3            gtMIB.u16DstPanID = gtMIB.u16PanID;
C51 COMPILER V9.53.0.0   IB_MAIN_SEN                                                       01/28/2020 11:28:56 PAGE 8   

 415   3            gtMIB.u16ShortAddr = INIT_DEV0_SHORTADDR;
 416   3            gtMIB.u16DstShortAddr = INIT_DEV1_SHORTADDR;
 417   3            for(iw=0 ; iw<8 ; iw++)
 418   3            {
 419   4              gtMIB.au8IEEEAddr[iw] = INIT_DEV0_IEEEADDR_LSB + iw;
 420   4              gtMIB.au8DstIEEEAddr[iw] = INIT_DEV1_IEEEADDR_LSB + iw;
 421   4            }
 422   3          }
 423   2          else if(u8DeviceMode == '1')
 424   2          {
 425   3            gtMIB.u8Channel = INIT_CHANNEL;
 426   3            gtMIB.u16PanID = INIT_PAN_ID;
 427   3            gtMIB.u16DstPanID = gtMIB.u16PanID;
 428   3            gtMIB.u16ShortAddr = INIT_DEV1_SHORTADDR;
 429   3            gtMIB.u16DstShortAddr = INIT_DEV0_SHORTADDR;
 430   3            for(iw=0 ; iw<8 ; iw++)
 431   3            {
 432   4              gtMIB.au8IEEEAddr[iw] = INIT_DEV1_IEEEADDR_LSB + iw;
 433   4              gtMIB.au8DstIEEEAddr[iw] = INIT_DEV0_IEEEADDR_LSB + iw;
 434   4            }
 435   3          }
 436   2              
 437   2        }
 438   1      
 439   1      
 440   1        //--- Destinaton MAC SET
 441   1        #if (TEST_NO_PAIR_MODE)
 442   1      
 443   1          gtPIB.uPairCount = 1;
 444   1          gtPIB.PairInfo.SrcID = gtMIB.au8IEEEAddr[0];
 445   1          gtPIB.u16PanID = gtMIB.u16PanID;
 446   1          
 447   1          // dest addre¸¦ ÀÚ±âÁÖ¼ÒÀÇ »óÀ§ 7 ÀÚ¸®´Â °°°Ô ÇÏ°í, ¸¶Áö¸· ÀÚ¸®´Â 0x00À¸·Î °­Á¦ ¼³Á¤
 448   1          rpmemcpy(gtMIB.au8DstIEEEAddr, gtMIB.au8IEEEAddr, 8);
 449   1          gtMIB.au8DstIEEEAddr[0] = 0x00;
 450   1      
 451   1          // copy short address
 452   1          gtMIB.u16DstShortAddr = gtMIB.au8DstIEEEAddr[1];
 453   1          gtMIB.u16DstShortAddr = gtMIB.u16DstShortAddr << 8 | gtMIB.au8DstIEEEAddr[0];
 454   1          
 455   1          u8AppRFSq = SQ_RF_TX_INIT;  
 456   1      
 457   1          #if _UARTDEBUG_MODE
                  zPrintf(1,"gtMIB.au8DstIEEEAddr : 0x%02x%02x%02x%02x%02x%02x%02x%02x\n", (short)gtMIB.au8DstIEEEAddr[7],
             -(short)gtMIB.au8DstIEEEAddr[6],(short)gtMIB.au8DstIEEEAddr[5],(short)gtMIB.au8DstIEEEAddr[4],(short)gtMIB.au8DstIEEEAddr
             -[3],(short)gtMIB.au8DstIEEEAddr[2],(short)gtMIB.au8DstIEEEAddr[1],(short)gtMIB.au8DstIEEEAddr[0]);
                  #endif
 460   1          
 461   1        #else
              
                  // flash¿¡ save µÈ Æä¾î¸µ µ¥ÀÌÅ¸¸¦ °¡Á®¿È 
                  if (Pair_PIB_COPY((UINT8*)&gtPIB) == 0) {
                    gtPIB.uPairCount = 0;               // flash read(gtPIB.uPairCount)ÇÏ¸é¼­ faile ½Ã 0xff °ªÀ» °¡Á®¿À°ÔµÊ   
                    u8AppRFSq = SQ_WAIT;                // pairingÀÌ µÇ¾î ÀÖÁö ¾ÊÀ¸¸é UART¸¦ ÅëÇØ  ¼öµ¿  pairing ¸¦ ¼öÇà 
                    u8LedState = LED_NO_PAIRED_STS;
              
                    //zPrintf(1, "\n >> uPairCount = %d", (short)gtPIB.uPairCount );
                    zPrintf(1, "\n  No Pair data : Do Pairing !!!");
                    AppLib_VirtualTimerSet(SQ_WAIT_TIMER, TIME_500MS);
                  } 
                  else {
                    Pair_Display_table();
C51 COMPILER V9.53.0.0   IB_MAIN_SEN                                                       01/28/2020 11:28:56 PAGE 9   

                    SetDestIEEEAddress(gtPIB.PairInfo.au8IEEEaddr);
              
                    #if (ZENER_BOARD)
                    u8AppRFSq = SQ_INIT_OVER_CHK;           // ´Ù¸¥ Å×½ºÆ® ¸ðµå #define ¿¡´Â Àû¿ë µÇÁö ¾ÊÀ½, Á¤»ó µ¿ÀÛ ¸ðµå 
                    AppLib_VirtualTimerSet(SQ_WAIT_TIMER,  1000);     // 1000ms µ¿¾È over current pin check 
                                            // 2000 : 150A¿¡¼­ over current µ¿ÀÛ , 1000 : 160A¿¡¼­ over current µ¿ÀÛ
                    #else
                    u8AppRFSq = SQ_RF_TX_INIT;      
                    #endif
                  } 
                #endif
 486   1      }
 487          //--------------------------------------------------------------------------------------------
 488          
 489          
 490          // Flash¿¡ ÀúÀåµÈ HIB ¸¦ °¡Á®¿Í MIB ¸¦ set
 491          // Kong.sh --> ZIGBEE PHY SETUP
 492          void  Init_MIB(void)
 493          {
 494   1      
 495   1        #if _EPAS_MODE
 496   1        gtMIB.u8NoAckRetry = 1;
 497   1        #else
                gtMIB.u8NoAckRetry = 3;
                #endif
 500   1        
 501   1        /// @param  u8PowerLevel  : level of transmitting power
 502   1        /// \n  0 = 9.0 dBm.   1 = 8.0 dBm.   2 = 8.0 dBm.    3 = 8.0 dBm....   9 = 0.0 dBm.
 503   1        /// \n  10 = -1 dBm....       18 = -10 dBm.
 504   1        /// \n  19 = -23 dBm.  20 = -27 dBm.  21 = -33 dBm.   22 = -64 dBm.
 505   1        gtMIB.u8TxPowerLevel = RF_TX_POWERLEVEL;    // power level °íÁ¤  
 506   1      
 507   1        //Initialize MIB : default value
 508   1        memset(gtMIB.au8DstIEEEAddr, 0x00, 8);
 509   1        memset(gtMIB.au8IEEEAddr, 0x00, 8);
 510   1        gtMIB.u16DstPanID = maccBroadcast;      // maccBroadcast = 0xFFFF
 511   1        gtMIB.u16DstShortAddr = maccBroadcast;    // maccBroadcast = 0xFFFF
 512   1        gtMIB.u16PanID = maccBroadcast;       // maccBroadcast = 0xFFFF
 513   1        gtMIB.u16ShortAddr = maccBroadcast;     // maccBroadcast = 0xFFFF
 514   1        #if _EPAS_MODE
 515   1        gtMIB.u8BackoffRetry = 5;
 516   1        #else
                gtMIB.u8BackoffRetry = 10;
                #endif
 519   1        gtMIB.u8Channel = 0x0B;
 520   1        gtMIB.u8DataRate = PHY_DATA_RATE_250K;
 521   1        gtMIB.u8DSN = 0xEE;
 522   1      
 523   1        Init_HIB();   // MAC SETUP
 524   1        
 525   1      
 526   1        // Æä¾î¸µÀ» ÇÏÁö ¾Ê´Â Å×½ºÆ® ¸ðµå ÀÏ¶§  destination address ¸¦ °­Á¦ ¼³Á¤ (´Ù¿î·Îµå½Ã ÇÏÀ§ 1¹ÙÀÌÆ® Á¦¿Ü ÇÏ
             -°í Á¤ÇØÁø °ªÀ¸·Î ´Ù¿î·Îµå ÇØ¾ßµÊ)
 527   1      #if  TEST_SENSOR
                // Ã¤³Î, ÆÒ¾ÆÀÌµð °íÁ¤  
                gtMIB.u8Channel = 11;           // ch=11
                gtMIB.u16PanID = 0x1210;
                gtMIB.u16DstPanID=gtMIB.u16PanID;       // dest PAN ID
              
              
                SetDestIEEEAddress((UINT8*) &COORDI_IEEE_ADDRESS);
                zPrintf(1, "\n Start Fixed Coordi Mode");   
C51 COMPILER V9.53.0.0   IB_MAIN_SEN                                                       01/28/2020 11:28:56 PAGE 10  

                zPrintf(1, " :DstIEEEAddr(0~7)=0x");
                Display_Buffer(gtMIB.au8DstIEEEAddr, 8, 0); 
              
                // !!!!!!!!! ID ·Î »ç¿ë 1 ~ 60 ¾Æ´Ï¸é µ¿ÀÛ ¾ÈÇÔ  !!!!!!!!!!!!!!!!!!
                // source IEEE address ¸¶Áö¸· ¹ÙÀÌÆ®¸¦ ID ·Î »ç¿ë 1 ~ 60
                if ( gtMIB.au8IEEEAddr[0] > 0 && gtMIB.au8IEEEAddr[0] <= MAX_END_DEVICE) {
                  gtPIB.PairInfo.SrcID = gtMIB.au8IEEEAddr[0];
                  gtPIB.uPairCount = 1;
                  u8AppRFSq = SQ_RF_TX_INIT;  
                  //Display_MIB(&gtMIB);
                }
                else
                  zPrintf(1, "\n Multi Comm test Sensor ID ERROR !!!!");    
                  
                    
                //Fixed_PanIDChannel_Address();
                
                Porduct_Mode |= PM_NOR_DBG_MODE;
              //  RED_LED = LED_ON;                 //RED  LED ON : pair OK
                
              #else
 557   1      
 558   1        #if (_USE_DIPSWITCH)  
                SetDipSwitch_ChannelPanID();                //  Return==>Port_ChPenID
                #endif
 561   1        
 562   1      #endif
 563   1        
 564   1        
 565   1        gtMIB.u8DSN = rand();
 566   1      
 567   1      }
 568          
 569          void Init_Adc(void)
 570          {
 571   1        INT16 i16AdcRead;
 572   1        UINT8 u8Status;
 573   1        extern INT16  gi16ADC_VCC, gi16ADC_GND;
 574   1      
 575   1        //----------------------------------------------------------------------------------------
 576   1            // ADC Init : maybe for Current sensor
 577   1        //----------------------------------------------------------------------------------------
 578   1        // Initialize Random Generator with SEED
 579   1        u8Status = SYS_AdcGet_Once(ADC_CHAN_TEMPERATURE, &i16AdcRead);
 580   1      
 581   1        #if _UARTDEBUG_MODE
                  u8Status = SYS_AdcGet_Once(ADC_CHAN_GND, &i16AdcRead);
                  zPrintf(1, "GND Adc = %6d\n",i16AdcRead);
                  AppLib_Delay(2);
                  u8Status = SYS_AdcGet_Once(ADC_CHAN_VCC, &i16AdcRead);
                  zPrintf(1, "VCC Adc = %6d\n",i16AdcRead);
                  AppLib_Delay(2);
                  u8Status = SYS_AdcGet_Once(ADC_CHAN_TEMPERATURE, &i16AdcRead);
                  zPrintf(1, "Inner TEMP Adc = %6d\n",i16AdcRead);
                #endif
 591   1        
 592   1        if(u8Status)
 593   1        {
 594   2          zPrintf(1, "\n AdcGet Error. Sta = 0x%02x",(short)u8Status);
 595   2        }
 596   1        srand((UINT16)i16AdcRead);
 597   1        
C51 COMPILER V9.53.0.0   IB_MAIN_SEN                                                       01/28/2020 11:28:56 PAGE 11  

 598   1          AvgBufferInit(AVG_CURR_BUFF_SIZE, &gtCurrentAvg );
 599   1              
 600   1        #if 0 
                SYS_AdcGet_VCCForCalib();
                SYS_AdcGet_GNDForCalib();
                #else 
 604   1        gi16ADC_VCC = ADCV_CAL_VCC;   // »ó¼ö°ªÀ¸·Î °íÁ¤  
 605   1        gi16ADC_GND = ADCV_CAL_GND;   // »ó¼ö°ªÀ¸·Î °íÁ¤  
 606   1        #endif
 607   1        
 608   1        //--- Kong.sh 190107 Modify..  Org --> SYS_AdcSet(ENABLE, 0, ADC_CHAN_0);
 609   1        #if _EPAS_MODE
 610   1        SYS_AdcSet(ENABLE, 0, ADC_CHAN_3);  //--- Kong.sh ADC_CHAN_0 --> ADC_CHAN_3 º¯°æ 19.12.27
 611   1        #else
                SYS_AdcSet(ENABLE, 0, ADC_CHAN_0);  
                #endif
 614   1      
 615   1      
 616   1        //GetInit_CurrentData();        // °íÀü·ù µ¿ÀÛ¿¡ µû¸¥ µð¹ö±× ¸ðµå ÁøÀÔ 
 617   1        
 618   1      }
 619            
 620          
 621          void  Init_Sensor(void)
 622          {
 623   1        // flash read : accel factor00000000
 624   1        // Kong test °¡¼Óµµ¼¾¼­ Á¦°ÅÈÄ Áö±×ºñ Åë½Å µ¿ÀÛ»óÅÂ¸¦ À¯ÁöÇÒ ¼ö ÀÖµµ·Ï ÇÏ±â À§ÇÏ¿© ÁÖ¼®Ã³¸®
 625   1        #if _ACCEL_USE
                HAL_FlashRead(CODE_ADDRESS_USER1, AccelerationSensor_ScalBuff, 511); //0x1400
                if((!(AccelerationSensor_ScalBuff[0]==0xFF))&&(!(AccelerationSensor_ScalBuff[1]==0xFF))&&
                (!(AccelerationSensor_ScalBuff[2]==0xFF)))
                {
                  AccelerationSensor_Scalefactor[0]=AccelerationSensor_ScalBuff[0];
                  AccelerationSensor_Scalefactor[1]=AccelerationSensor_ScalBuff[1];
                  AccelerationSensor_Scalefactor[2]=AccelerationSensor_ScalBuff[2];   
                }
                else
                {
                  AccelerationSensor_Scalefactor[0]=0;
                  AccelerationSensor_Scalefactor[1]=0;
                  AccelerationSensor_Scalefactor[2]=0;    
                }
                #else
 641   1        // °¡¼Óµµ¼¾¼­ Á¦°ÅÈÄ Áö±×ºñ Åë½Å µ¿ÀÛ»óÅÂ¸¦ À¯ÁöÇÒ ¼ö ÀÖµµ·Ï ÇÏ±â À§ÇÏ¿© Ãß°¡ÇÑ ÀÓ½Ã ÄÚµå ½ÃÀÛ
 642   1        AccelerationSensor_Scalefactor[0]=0x01;
 643   1        AccelerationSensor_Scalefactor[1]=0x02;
 644   1        AccelerationSensor_Scalefactor[2]=0x03;   
 645   1        #endif
 646   1        
 647   1        // flash read : cal data
 648   1        #if 0 // org code
                HAL_FlashRead(CODE_ADDRESS_USER2, CurCal_DataBuff, 511);
                
                if(((CurCal_DataBuff[0]==0xFF))&&((CurCal_DataBuff[4]==0xFF))&&((CurCal_DataBuff[8]==0xFF))
                &&((CurCal_DataBuff[12]==0xFF))&&((CurCal_DataBuff[16]==0xFF)))
                {
                  Inver_A = 0;  
                  Inver_B = 0;  
                  Inver_C = 1;
                  Inver_D = 0;  
                }
                else
C51 COMPILER V9.53.0.0   IB_MAIN_SEN                                                       01/28/2020 11:28:56 PAGE 12  

                {
                  memcpy(&Test_int32, &CurCal_DataBuff, 4);
                  Inver_A = *((float*)&Test_int32); 
                  memcpy(&Test_int32, &CurCal_DataBuff[4], 4);
                  Inver_B = *((float*)&Test_int32); 
                  memcpy(&Test_int32, &CurCal_DataBuff[8], 4);
                  Inver_C = *((float*)&Test_int32);
                  memcpy(&Test_int32, &CurCal_DataBuff[12], 4);
                  Inver_D = *((float*)&Test_int32);
                }   
                #else
 671   1        // zener board : Á¦³Ê Àü·ù »ç¿ë ÇÏ¿© Àü·ù ¼¾½Ì µ¥ÀÌÅ¸ °è»ê À§ÇÑ ÆÄ¶ó¸ÞÅ¸
 672   1        HAL_FlashRead(CODE_ADDRESS_USER2, CurCal_DataBuff, 511);
 673   1        
 674   1        if ((CurCal_DataBuff[0] !=0xFF) && (CurCal_DataBuff[1] !=0xFF)){
 675   2          u8StartZenorADC = CurCal_DataBuff[0];
 676   2          u8RecoveryZenorADC = CurCal_DataBuff[1];
 677   2          if (u8StartZenorADC <= u8RecoveryZenorADC)
 678   2            u8RecoveryZenorADC = u8StartZenorADC - 0x08;    // recovery hysterisys 
 679   2        }
 680   1        
 681   1        #if  (ZENER_BOARD == 1)
                  if (_IS_NO_SLEEP_MODE)
                    zPrintf(1," Zener ADC Start / Recovery Value : 0x%02x   0x%02x \r",  (short)u8StartZenorADC, (short)u8R
             -ecoveryZenorADC);
                #endif
 685   1        
 686   1        #endif  
 687   1      
 688   1        //----------------------------------------------------------------------------------------
 689   1        // Accelerometer Init
 690   1        //----------------------------------------------------------------------------------------
 691   1        // Kong °¡¼Óµµ¼¾¼­ Á¦°ÅÈÄ Áö±×ºñ Åë½Å µ¿ÀÛ»óÅÂ¸¦ À¯ÁöÇÒ ¼ö ÀÖµµ·Ï ÇÏ±â À§ÇÏ¿© ÁÖ¼®Ã³¸®
 692   1        #if _ACCEL_USE
                AccelSensor_Init();
                #endif
 695   1      
 696   1        //----------------------------------------------------------------------------------------
 697   1        // Temperature Init 
 698   1        //----------------------------------------------------------------------------------------
 699   1        TempSensor_Init();
 700   1      
 701   1        //----------------------------------------------------------------------------------------
 702   1        //  Current Sensor(ADC) Init  
 703   1        //----------------------------------------------------------------------------------------
 704   1        Init_Adc();
 705   1        
 706   1      }
 707          
 708          
 709          void Init_VerDisplay(void)
 710          {
 711   1      
 712   1        if ((_IS_NO_SLEEP_MODE) || ( _IS_PM_DBG_MODE)) {
 713   2      
 714   2          zPrintf(1, "\n ************************************************");
 715   2          zPrintf(1, "\n [HELP] : FF AC 02 01 03 B1 0D 0A");
 716   2          zPrintf(1, "\n End Device");
 717   2          zPrintf(1, "\n I.B Technology Co., Ltd. , 2014");       
 718   2      
 719   2          #if (ZENER_BOARD == 1)
                    zPrintf(1, "\n SW Ver= %s_SSDAE_ZENER ", (UINT8*)&FW_UPDATE_DATE); 
C51 COMPILER V9.53.0.0   IB_MAIN_SEN                                                       01/28/2020 11:28:56 PAGE 13  

                  #elif (TEMP_SEN_MODE == THERM_SEN)
 722   2            zPrintf(1, "\n SW Ver= %s_SSDAE_THERM ", (UINT8*)&FW_UPDATE_DATE); 
 723   2          #elif (TEMP_SEN_MODE == INT_SEN)  
                    zPrintf(1, "\n SW Ver= %s_SSDAE_INT ", (UINT8*)&FW_UPDATE_DATE); 
                  #else
                    zPrintf(1, "\n SW Ver= %s_SSDAE_EXT ", (UINT8*)&FW_UPDATE_DATE); 
                  #endif
 728   2        
 729   2          zPrintf(1, "V%c.%c%c%c ", SSE_VER_MAIN, SSE_VER_SUB1, SSE_VER_SUB2, SSE_VER_PATCH);
 730   2          //zPrintf(1, "\n Power Station ID = %d", (short)PWR_ST_ID);
 731   2          zPrintf(1, "\n ************************************************");  
 732   2        }
 733   1      
 734   1      }
 735          
 736          
 737          void Init_GetMode(void)
 738          {
 739   1        
 740   1        //--------------------------------------------------------------------------
 741   1        // ÃßÈÄ ¹ßÀü¼Ò ID¸¦ ÀÐ¾î µé¿© booting½Ã ¸ðµå ¼³Á¤À» ÇÒ¼ö ÀÖµµ·Ï : ÁÖ¼Ò LSB 3¹øÂ°°¡ ¹ßÀü¼Òº° ÇÒ´ç µÇ¾î ÀÖÀ
             -½ !!
 742   1        // »óÀ§ ¹«¼± Æä¾î¸µ ¸í·É½Ã ¹ßÀü¼Ò ID¸¦ ÀúÀåÇÏ¿© default µ¿ÀÛ ¸ðµå¸¦ °áÁ¤ ÇÏµµ·Ï
 743   1        // Pair_PIB_COPY((UINT8*)&gtPIB);
 744   1        //--------------------------------------------------------------------------
 745   1        #if (_EPAS_MODE == 1 )
 746   1      
 747   1          Porduct_Mode |= PM_SLEEP_MODE;          // default OFF : sleep mode  
 748   1      
 749   1          #if _POWERDOWN_USE
 750   1            //HAL_PowerdownGpio1WakeupSourceSet(4, 1, 0);       // wakeup interrupt pin : p1.4 (pairing button)   
 751   1            //HAL_PowerdownGpio3WakeupSourceSet(2, 1, 0);       // Á¦³Ê º¸µå¿¡ ¸¸ Àû¿ë overcurrent wakeup interrupt pi
             -n : p3.2    
 752   1      
 753   1            #if (_POWERDOWN_MODE==1)
 754   1              #if _UARTDEBUG_MODE
                      zPrintf(1,"getMode->PWDown1\n");
                      AppLib_DelayFor1ms();
                      #endif
 758   1              HAL_PowerdownMode1(POWER_DOWN_TIME_INIT, 0, 0, 0);    //  30 sec  : wiat for normal power 
 759   1            #elif (_POWERDOWN_MODE==2)
                      #if _UARTDEBUG_MODE
                      zPrintf(1,"getMode->PWDown2\n");
                      AppLib_DelayFor1ms();
                      #endif
                      HAL_PowerdownMode2(POWER_DOWN_TIME_INIT, 0, 0, 0);    //  MODE2ÀÏ °æ¿ì SW Reset µÊ..
                    #elif (_POWERDOWN_MODE==3)
                      #if _UARTDEBUG_MODE
                      zPrintf(1,"getMode->PWDown3\n");
                      AppLib_DelayFor1ms();
                      #endif
                      HAL_PowerdownMode3(0);                  //  MODE3 --> Wakeup Only External Int
              
                    #endif
 773   1            
 774   1            //HAL_PowerdownGpio3WakeupSourceSet(2, 0, 0);       // Á¦³Ê º¸µå¿¡ ¸¸ Àû¿ë overcurrent wakeup interrupt pi
             -n : p3.2    
 775   1          #endif
 776   1          
 777   1        #elif (_EPAS_MODE == 0 )
                
                  if (UART_DBG_MODE_PIN == 0) 
C51 COMPILER V9.53.0.0   IB_MAIN_SEN                                                       01/28/2020 11:28:56 PAGE 14  

                    Porduct_Mode |= (PM_UART_DBG_MODE |  PM_SLEEP_MODE) ; // Áö±×º¸µå¸¦ ÅëÇÑ uart pin µð¹ö±× ¸ðµå  : sleep 
             -mode µ¿ÀÛ   
                    
                  else if (PAIRING_BUTTON == BTN_ON)          
                    Porduct_Mode |= PM_NOR_DBG_MODE;            // booting Áß Æä¾î¸µ ¹öÆ° ´­¸² Ã³¸®  : DBG mode ´Â sleep mode »ç
             -¿ë ÇÏÁö ¾ÊÀ½  
                    
                  else
                  {
                    if (WAKEUP_FAST_MODE == I_PORT_ON)          // DIP SWITCH bit9  : bit9°¡ ON  ÀÌ¸é  1sec  wakeup mode µ¿ÀÛ, 
             -No init wait(30sec)     
                      Porduct_Mode |= PM_OVER_CURR_MODE;
                          else
                            Porduct_Mode |= PM_SLEEP_MODE;          // default OFF : sleep mode  
                  } 
                    
                  if (SLEEP_FAST_MODE == I_PORT_ON)             // bit9°¡ ON ÀÌ¶óµµ bit10ÀÌ ON ÀÌ¸é sleep mode µ¿ÀÛ 
                  {
                    Porduct_Mode |= PM_SLEEP_MODE;
                    u8_SLEEP_TIME = 1;                    // DIP SWITCH MSB(bit10)  : bit10°¡ ON  ÀÌ¸é  sleep mode 1sec  µ¿ÀÛ     
                  } 
              
                  // booting Áß Æä¾î¸µ ¹öÆ° ´­¸² Ã³¸®  : DBG mode ´Â sleep mode »ç¿ë ÇÏÁö ¾ÊÀ½  
                  if (_IS_PM_DBG_MODE)      
                    zPrintf(1, "\n >>  DEBUG MODE  ..."); 
              
                  //else if ((Porduct_Mode &  PM_SLEEP_MODE) && (~Porduct_Mode & PM_OVER_CURR_MODE))  {
                  else if (Porduct_Mode & PM_SLEEP_MODE)  
                  {
                    #if _UARTDEBUG_MODE
                    zPrintf(1,"getMode->DBG MODE\n");
                    AppLib_DelayFor1ms();
                    #endif
              
                    HAL_PowerdownGpio1WakeupSourceSet(4, 1, 0);       // wakeup interrupt pin : p1.4 (pairing button)   
                    HAL_PowerdownGpio3WakeupSourceSet(2, 1, 0);       // Á¦³Ê º¸µå¿¡ ¸¸ Àû¿ë overcurrent wakeup interrupt pin 
             -: p3.2    
              
                    AppLib_DelayFor1ms();
                    HAL_PowerdownMode1(POWER_DOWN_TIME_INIT, 0, 0, 0);    //  30 sec  : wiat for normal power 
                    HAL_PowerdownGpio3WakeupSourceSet(2, 0, 0);       // Á¦³Ê º¸µå¿¡ ¸¸ Àû¿ë overcurrent wakeup interrupt pin 
             -: p3.2    
                  }     
                #endif
 819   1      }
 820          
 821          // PM_UART_DBG_MODE : Áö±×º¸µå uart pin, sleep mode 
 822          // PM_NOR_DBG_MODE : pairing button, wakeup mode 
 823          void Init_FlashDefault(void)
 824          {
 825   1      
 826   1        TxTimePeriod = TX_TIME_PERIOD;            //  ¼Û½Å ÁÖ±â  : 5È¸(5sec ÁÖ±â ¼Û½Å) 
 827   1        //  WAKEUP_TX_PERIOD(dip seitch 2nd MSB): Å×½ºÆ®¸¦ À§ÇØ µö½ºÀ§Ä¡ ¼³Á¤½Ã µ¿ÀÛ È®ÀÎ ¹× Å×½ºÆ®¸¦ À§ÇØ 1ÃÊ °£
             -°ÝÀ¸·Î µ¿ÀÛ ÇÏµµ·Ï »ç¿ë 
 828   1        if ((Porduct_Mode &  PM_SLEEP_MODE) || (Porduct_Mode &  PM_NOR_DBG_MODE) ||  (WAKEUP_FAST_MODE == 0) ) 
 829   1          TxTimePeriod = 1;               // sleep mode ÀÏ °æ¿ì TxTimePeriod ´Â Ç×»ó 1·Î ÇØ¾ßµÊ 
 830   1          
 831   1        //--------------------------------------------------------------------------
 832   1        // option °ªÀÌ ÀÏÀ» °æ¿ì ¿É¼Ç °ªÀ» »ó¼ö·Î »ç¿ë 
 833   1      
 834   1        if (_USE_OPTION_VALUE) {
 835   2          #if _UARTDEBUG_MODE
C51 COMPILER V9.53.0.0   IB_MAIN_SEN                                                       01/28/2020 11:28:56 PAGE 15  

                  zPrintf(1,"_USE OPTION VALUE is True\n");
                  #endif
 838   2        
 839   2          if (gtPIB.Option.u8Option3 <= POWER_DOWN_TIME)  // 10ÃÊ(1sec 10È¸ )
 840   2            TxTimePeriod = gtPIB.Option.u8Option3;
 841   2          if (gtPIB.Option.u8Option4 <= POWER_DOWN_TIME)  // 10ÃÊ
 842   2            u8_SLEEP_TIME = gtPIB.Option.u8Option4;
 843   2      
 844   2          if (_IS_NO_SLEEP_MODE) {
 845   3            zPrintf(1," 0x80 :  Use Option Value");
 846   3            zPrintf(1,"(Tx Time  = %02d, Sleep Time = %02d)",(short)TxTimePeriod, (short)u8_SLEEP_TIME);
 847   3          }     
 848   2        }
 849   1      
 850   1        // Get PANID and RF Channel
 851   1        if (_IS_NO_DIP_SWITCH) {
 852   2          // dip seitch ¼³Á¤À» ¼öµ¿À¸·Î ÇÒ¼ö ÀÖµµ·Ï 
 853   2          gtPIB.u16PanID = (gtMIB.u16PanID & 0xFF00) | ((gtPIB.Option.u8Pid_Chan >> 4) & 0x0F); // pan id 
 854   2          gtPIB.u8Channel = (gtPIB.Option.u8Pid_Chan  & 0x0F) + 11;              // channel 
 855   2      
 856   2          //#if _EPAS_MODE    
 857   2          //gtMIB.u16PanID = gtPIB.u16PanID;
 858   2          //gtMIB.u16DstPanID=gtMIB.u16PanID; 
 859   2          //gtMIB.u8Channel = gtPIB.u8Channel; 
 860   2          //#endif
 861   2          
 862   2          Set_ChannelPanID();   // ÀúÀåµÈ pan id, channel »ç¿ë 
 863   2          
 864   2        } 
 865   1        
 866   1        #if _EPAS_MODE
 867   1          // Thermistor adc offset
 868   1          u16TempOffset = TEMP_OFFSET;  
 869   1          
 870   1          #if _UARTDEBUG_MODE
                  zPrintf(1,"u16TempOffset = %6d\n",u16TempOffset);
                  #endif
 873   1        #else
                if (gtPIB.Option.u16Option1 != 0xFF)
                {
                  // Thermistor adc offset
                  u16TempOffset = gtPIB.Option.u16Option1;
              
                  #if _UARTDEBUG_MODE
                  zPrintf(1,"u16TempOffset = %6d\n",u16TempOffset);
                  #endif
                }
                
                #endif
 885   1        //--------------------------------------------------------------------------
 886   1      
 887   1        u8_SLEEP_TIME_Prev = u8_SLEEP_TIME;         // PM_OVER_CURR_MODE mode°¡ ¾Æ´Ï¸é u8_SLEEP_TIME_Prev ¸¦ »ç¿ë ÇÏÁ
             -ö ¾ÊÀ½
 888   1      
 889   1        // sleep mode¿¡¼­ debug mode µ¿ÀÛ : sleep time À» ÁÙÀÌ±â À§ÇØ     
 890   1        if (Porduct_Mode & PM_UART_DBG_MODE)
 891   1          u8_SLEEP_TIME = POWER_DOWN_TIME_UART_DBG; // default 10 -> 5ÃÊ  
 892   1      
 893   1      } 
 894          
 895          
 896          ///////////////////////////////////////////////////////////////////////////////////////////////
C51 COMPILER V9.53.0.0   IB_MAIN_SEN                                                       01/28/2020 11:28:56 PAGE 16  

 897          /// 
 898          ///   Callback function called in PHY_ISR() when OOB(Out-Of-Band) code in a received packet is not 0.
 899          /// \n  OOB code is contained in the reserved fields of IEEE 802.15.4 frame format. And, on the specificati
             -on,
 900          ///   the fiedls should be 0. In other words, OOB is out of the specification. It means that a OOB packet a
             -re not 
 901          ///   compatible to the packet for IEEE 802.15.4 specification.
 902          /// \n  If a received packet is processed in this function, the return value should be 1. Then, the packet 
             -is 
 903          ///   discarded in the PHY_ISR(). It prevents duplicated processing for the packet.
 904          /// \n  Otherwise, the return value should be 0. It means that the packet is processed in PHY_ISR().
 905          ///
 906          /// @param  u8RxFifoStartIdx  : Start address of the received packet including the length field in MAC RXFIF
             -O.
 907          /// @return UINT8. Status of processing. 0=Not processed, 1=Processed.
 908          /// 
 909          ///////////////////////////////////////////////////////////////////////////////////////////////
 910          UINT8 Callback_OobRxFromPhyISR(UINT8 u8RxFifoStartIdx)
 911          {
 912   1        u8RxFifoStartIdx = 0;
 913   1      
 914   1        return  0;
 915   1      }
 916          
 917          
 918          ///////////////////////////////////////////////////////////////////////////////////////////////
 919          /// 
 920          ///   Reports the HAL code(Higher 2bytes) and the return code(Lower 2bytes) if a error is occured when call
             -ing HAL
 921          /// functions. This is called only in DEBUG mode.
 922          ///
 923          /// @param  u16ErrorCode    : bit[31:16]=HAL code. bit[15:0]=Return code.
 924          /// @return void
 925          /// 
 926          ///////////////////////////////////////////////////////////////////////////////////////////////
 927          #ifdef  DEBUG
              void assert_failed(UINT16 u16ErrorCode)
              {
                // TODO:  The user can add his own implementation to report the error code. e.g. zPrintf().
              #ifdef __MG2470_UART1_INCLUDE__
                if(ES1 && UART1_CLK_STATE)
                {
                  zPrintf(1, "\n ## ErrorCode = 0x%04x ##", u16ErrorCode);
                }
              #endif
              }
              #endif
 939           
 940            
 941          UINT8 u8LedState = LED_PAIRED_STS;
 942          // ----------------------------------------------------------------------------------------------------
 943          // - Æä¾î¸µ µ¿ÀÛ : red, blue blinking
 944          //  - 1. Sleep mode,   2. wakeup mode
 945          //   > No pair data : 1 = red ON,  2 = red OFF 
 946          //   > pair data : 1 = red OFF,      2 = red ON 
 947          //  > ¼Û½Å OK : 1,2 = blue blink
 948          //  > ¼Û½Å Fail : 1 = blue blink, led blink,  2 = blue on 
 949          //   > Normal :  1 = red = OFF, blue = OFF,  2 = red ON, blue = OFF 
 950          // ----------------------------------------------------------------------------------------------------
 951           
 952          // LedState °¡ º¯°æ µÈÈÄ LED_IDLE_STS ¿¡¼­ wait  
 953          void LED_Process(void)
C51 COMPILER V9.53.0.0   IB_MAIN_SEN                                                       01/28/2020 11:28:56 PAGE 17  

 954           {
 955   1        if (Porduct_Mode &  PM_SLEEP_MODE) {
 956   2          switch(u8LedState) {
 957   3            case LED_IDLE_STS :
 958   3              
 959   3              break;
 960   3            // led, led blinking      
 961   3            case LED_NO_PAIRED_STS :      // when pairing FAIL 
 962   3                if (AppLib_VirtualTimerGet(LED_CONT_TIMER) == 0) {
 963   4                RED_LED = LED_ON;
 964   4                AppLib_VirtualTimerSet(LED_CONT_TIMER, TIME_100MS);
 965   4                  u8LedState = LED_NO_PAIRED_STS1;
 966   4                } 
 967   3                break;
 968   3                
 969   3                case LED_NO_PAIRED_STS1 :
 970   3                if (AppLib_VirtualTimerGet(LED_CONT_TIMER) == 0) {
 971   4                RED_LED = LED_OFF;
 972   4                AppLib_VirtualTimerSet(LED_CONT_TIMER, TIME_1SEC);
 973   4                  u8LedState = LED_NO_PAIRED_STS;
 974   4                } 
 975   3                break;
 976   3                
 977   3              case LED_PAIRING_STS :
 978   3                if (AppLib_VirtualTimerGet(LED_CONT_TIMER) == 0) {
 979   4                BLUE_LED = LED_ON;
 980   4                RED_LED = LED_OFF;
 981   4                AppLib_VirtualTimerSet(LED_CONT_TIMER, TIME_500MS);
 982   4                  u8LedState = LED_PAIRING_STS1;
 983   4                } 
 984   3                break;
 985   3                
 986   3                case LED_PAIRING_STS1 :
 987   3                if (AppLib_VirtualTimerGet(LED_CONT_TIMER) == 0) {
 988   4                BLUE_LED = LED_OFF;
 989   4                RED_LED = LED_ON;
 990   4                AppLib_VirtualTimerSet(LED_CONT_TIMER, TIME_500MS);
 991   4                  u8LedState = LED_PAIRING_STS;
 992   4                } 
 993   3                break;
 994   3              
 995   3              case LED_TX_STS :
 996   3              BLUE_LED = LED_ON;
 997   3              AppLib_VirtualTimerSet(LED_CONT_TIMER, 10);
 998   3                u8LedState = LED_IDLE_STS;
 999   3                break;
1000   3      
1001   3                case LED_TX_OK_STS :
1002   3                  if (AppLib_VirtualTimerGet(LED_CONT_TIMER) == 0) {
1003   4                BLUE_LED = LED_OFF;
1004   4                  u8LedState = LED_IDLE_STS;
1005   4               }  
1006   3                break;
1007   3              
1008   3                case LED_TX_FAIL_STS :
1009   3                  if (AppLib_VirtualTimerGet(LED_CONT_TIMER) == 0) {
1010   4                BLUE_LED = LED_OFF;
1011   4                RED_LED = LED_ON;   // sleep mode ÁøÀÔ½Ã ¸ðµç led OFF ÈÄ ÁøÀÔ 
1012   4                  u8LedState = LED_IDLE_STS;
1013   4               }  
1014   3                break;
1015   3              
C51 COMPILER V9.53.0.0   IB_MAIN_SEN                                                       01/28/2020 11:28:56 PAGE 18  

1016   3            case LED_NORMAL_STS :
1017   3              BLUE_LED = LED_OFF;
1018   3              RED_LED = LED_OFF;
1019   3            
1020   3                u8LedState = LED_IDLE_STS;
1021   3              break;
1022   3          }
1023   2        }
1024   1        else {  
1025   2          //  wakeup mode
1026   2          switch(u8LedState) {
1027   3            case LED_IDLE_STS :
1028   3              
1029   3              break;
1030   3            // led, led blinking      
1031   3            case LED_NO_PAIRED_STS :      // when pairing FAIL 
1032   3                if (AppLib_VirtualTimerGet(LED_CONT_TIMER) == 0) {
1033   4                RED_LED = LED_ON;
1034   4                AppLib_VirtualTimerSet(LED_CONT_TIMER, TIME_500MS);
1035   4                  u8LedState = LED_NO_PAIRED_STS1;
1036   4                } 
1037   3                break;
1038   3                
1039   3                case LED_NO_PAIRED_STS1 :
1040   3                if (AppLib_VirtualTimerGet(LED_CONT_TIMER) == 0) {
1041   4                RED_LED = LED_OFF;
1042   4                AppLib_VirtualTimerSet(LED_CONT_TIMER, TIME_500MS);
1043   4                  u8LedState = LED_NO_PAIRED_STS;
1044   4                } 
1045   3                break;
1046   3            
1047   3              case LED_PAIRED_STS :       // when pairing OK  
1048   3              RED_LED = LED_ON;
1049   3              BLUE_LED = LED_OFF;
1050   3              
1051   3                u8LedState = LED_NORMAL_STS;
1052   3                break;
1053   3              
1054   3              // led, blue led blinking           
1055   3              case LED_PAIRING_STS :
1056   3                if (AppLib_VirtualTimerGet(LED_CONT_TIMER) == 0) {
1057   4                BLUE_LED = LED_ON;
1058   4                RED_LED = LED_OFF;
1059   4                AppLib_VirtualTimerSet(LED_CONT_TIMER, TIME_500MS);
1060   4                  u8LedState = LED_PAIRING_STS1;
1061   4                } 
1062   3                break;
1063   3                
1064   3                case LED_PAIRING_STS1 :
1065   3                if (AppLib_VirtualTimerGet(LED_CONT_TIMER) == 0) {
1066   4                BLUE_LED = LED_OFF;
1067   4                RED_LED = LED_ON;
1068   4                AppLib_VirtualTimerSet(LED_CONT_TIMER, TIME_500MS);
1069   4                  u8LedState = LED_PAIRING_STS;
1070   4                } 
1071   3                break;
1072   3              
1073   3              case LED_TX_STS :
1074   3              BLUE_LED = LED_ON;
1075   3              AppLib_VirtualTimerSet(LED_CONT_TIMER, 10);
1076   3      
1077   3                u8LedState = LED_IDLE_STS;
C51 COMPILER V9.53.0.0   IB_MAIN_SEN                                                       01/28/2020 11:28:56 PAGE 19  

1078   3                break;
1079   3      
1080   3                case LED_TX_OK_STS :
1081   3                  if (AppLib_VirtualTimerGet(LED_CONT_TIMER) == 0) {
1082   4                BLUE_LED = LED_OFF;
1083   4                  u8LedState = LED_IDLE_STS;
1084   4               }  
1085   3                break;
1086   3              
1087   3                case LED_TX_FAIL_STS :
1088   3                  if (AppLib_VirtualTimerGet(LED_CONT_TIMER) == 0) {
1089   4                BLUE_LED = LED_ON;
1090   4                // RED_LED = LED_ON;      // pair »óÅÂ¿¡¼­ Ç×»ó ON 
1091   4                  
1092   4                  u8LedState = LED_IDLE_STS;
1093   4               }  
1094   3                break;
1095   3              
1096   3            case LED_NORMAL_STS : 
1097   3              BLUE_LED = LED_OFF;
1098   3              RED_LED = LED_ON;
1099   3            
1100   3                u8LedState = LED_IDLE_STS;
1101   3              break;
1102   3          }   
1103   2        }   
1104   1        } 
1105          
1106          
1107            
1108          ///////////////////////////////////////////////////////////////////////////////////////////////
1109          /// 
1110          ///   Main function.
1111          ///
1112          /// @param  void
1113          /// @return void
1114          /// 
1115          ///////////////////////////////////////////////////////////////////////////////////////////////
1116          #if 0
              void main(void)
              {
                HAL_McuPeriClockSet(CLOCK_MODE_16_MHz);
              
                //  TIMER0 : Turn on the clock and Set
                HAL_Timer0ClockOn(OFF); // Org ON
                HAL_Timer0IntSet(DISABLE, PRIORITY_LOW, RUN, 2);  // Org ENABLE
              
                //  UART1 : Turn on the clock and Set
                #if _UARTDEBUG_MODE
                HAL_Uart1ClockOn(ON);
                HAL_Uart1IntSet(ENABLE, PRIORITY_LOW, 115200, UART_MODE_8N1);
                #endif
              
                // Kong - Áøµ¿¼¾¼­¿ë I2C Init --> Turn on the clock and Set
                #if _ACCEL_USE
                HAL_I2CClockOn(1);
                HAL_I2CIntSet(1,1,1,28);//20  
                #endif
              
                // Interrupt Enable
                #if _UARTDEBUG_MODE
                HAL_SystemIntSet(ENABLE);     // EA=1
C51 COMPILER V9.53.0.0   IB_MAIN_SEN                                                       01/28/2020 11:28:56 PAGE 20  

                zPrintf(1, "\n\r>> Reset Init..\n");
                #endif
              
                //  GPIO : Turn on the clock and Set
                // TODO: Set GPIOs to be used if needed.  
                HAL_GpioClockOn(OFF);
              
                HAL_Gpio0InOutSet(0, GPIO_INPUT, GPIO_PULL_UP);         // 0À¸·Î ÀÎÁö½Ã ¼¾¼­ TEST MODE·Î µ¿ÀÛµÊ. ÁÖÀÇ ¿ä¸Á..
                HAL_Gpio0InOutSet(1, GPIO_INPUT, GPIO_PULL_UP);
                HAL_Gpio0InOutSet(2, GPIO_INPUT, GPIO_PULL_UP);
                HAL_Gpio0InOutSet(3, GPIO_INPUT, GPIO_PULL_UP);
                HAL_Gpio0InOutSet(4, GPIO_INPUT, GPIO_PULL_UP);
                HAL_Gpio0InOutSet(5, GPIO_INPUT, GPIO_PULL_UP);
                HAL_Gpio0InOutSet(6, GPIO_INPUT, GPIO_PULL_UP);
                HAL_Gpio0InOutSet(7, GPIO_INPUT, GPIO_PULL_UP);
              
                // P1.0 : booting ½Ã µð¹ö±× ¸ðµå Ã¼Å© input pinÀ¸·Î »ç¿ë
                HAL_Gpio1InOutSet(0, GPIO_INPUT, GPIO_PULL_UP);   //UART_RXD1 : UART_DBG_MODE_PIN  
                HAL_Gpio1InOutSet(1, GPIO_INPUT, GPIO_PULL_UP);   //UART_RXD1 : UART_DBG_MODE_PIN  
                HAL_Gpio1InOutSet(3, GPIO_OUTPUT, GPIO_DRIVE_4mA);  ACCELSEN_RESET = RST_OFF; //TP5 
                HAL_Gpio1InOutSet(4, GPIO_INPUT, GPIO_PULL_UP);
                HAL_Gpio1InOutSet(6, GPIO_INPUT, GPIO_PULL_UP);
                HAL_Gpio1InOutSet(7, GPIO_INPUT, GPIO_PULL_UP);
              
                HAL_Gpio3InOutSet(0, GPIO_INPUT, GPIO_PULL_UP);
                HAL_Gpio3InOutSet(1, GPIO_INPUT, GPIO_PULL_UP);
                HAL_Gpio3InOutSet(2, GPIO_INPUT, GPIO_PULL_UP);
                HAL_Gpio3InOutSet(3, GPIO_INPUT, GPIO_PULL_UP);
                HAL_Gpio3InOutSet(4, GPIO_INPUT, GPIO_PULL_UP);
                HAL_Gpio3InOutSet(5, GPIO_OUTPUT, GPIO_DRIVE_4mA);  GP35 = 1;   // NTC Thermostor Ref Line GND Connection..
                HAL_Gpio3InOutSet(6, GPIO_INPUT, GPIO_PULL_UP);
                HAL_Gpio3InOutSet(7, GPIO_INPUT, GPIO_PULL_UP);
              
                if(xCHIPID == 0x70)
                {
                  zPrintf(1, "\n Failed. This software only supports CHIP ID over 0x70 !!!");
                  while(SYS_Uart1TxWorking());
                  SYS_WdtReset(0);
                }
              
                init_mempool(&malloc_mem, sizeof(malloc_mem));
                Init_HAL_Modem();
                //Init_GetMode();
                Init_MIB();             // RF Init..
                Init_GetPIB();
                //Init_FlashDefault();
                Security_Material();        // Security Init    
              
                SYS_AdcSet(ENABLE, 0, ADC_CHAN_3);  
              
                while(1)
                {
                  // RF Init....
                  // NT Thermistor Read
                  // RF Send
                  // Sleep (Power Down Mode2)
              
                  #if _UARTDEBUG_MODE
                  zPrintf(1,"getMode->PWDown2\n");
                  AppLib_DelayFor1ms();
                  #endif
                  HAL_PowerdownMode2(3, 0, 0, 0);   //  MODE2ÀÏ °æ¿ì SW Reset µÊ..
C51 COMPILER V9.53.0.0   IB_MAIN_SEN                                                       01/28/2020 11:28:56 PAGE 21  

                  
                }
              }
              
              
              #endif
1208          
1209          #if 1
1210          void main(void)
1211          {
1212   1        HAL_McuPeriClockSet(gu8McuPeriClockMode);
1213   1      
1214   1        //  Watchdog Disable
1215   1        SYS_WdtSet(0);
1216   1        
1217   1        Init_SysConfig();
1218   1        init_mempool(&malloc_mem, sizeof(malloc_mem));
1219   1      
1220   1        #if !_EPAS_MODE
                SYS_WdtSet(2000);
                #endif
1223   1      
1224   1        Init_HAL_Modem();         // power down Àü¿¡ ÃÊ±âÈ­°¡ ÀÌ·ç¾î Á®¾ß µÊ 
1225   1        Init_GetMode();         // µð¹ö°Å ¸ðµå°¡ ¾Æ´Ï¸é Powerdown  :  init 30 sec
1226   1        
1227   1        //Init_PER(&tPER);              // Not used 
1228   1        //Init_VerDisplay();
1229   1        Init_MIB();             // RF Init..
1230   1        //Init_GetPIB();
1231   1        
1232   1        Init_FlashDefault();
1233   1        
1234   1        Security_Material();          // Security Init    
1235   1        
1236   1        // T1   
1237   1        Init_RF_HAL();              // T1
1238   1        Init_Sensor();
1239   1      
1240   1        Sensor_Mode = _SENSOR_PACKET_TXMODE;  // Packet RF Ãâ·Â¸ðµå 0 , Packet UART Ãâ·Â¸ðµå 1
1241   1        //-------------------------------------------------------------------------
1242   1        while(1)
1243   1        {
1244   2          #if !_EPAS_MODE
                  SYS_WdtSet(10000);
                  #else
1247   2          SYS_WdtSet(0);
1248   2          #endif
1249   2      
1250   2          #if (_POWERDOWN_USE==0)
                  AppLib_Delay(1);
                  #endif
1253   2      
1254   2          //----------------------------------------------------------------
1255   2          // PLL can be unlocked when the temperature is changed rapidly within short time.
1256   2          // Then, re-locking is required.
1257   2          HAL_LockStateCheck();       // T1   
1258   2          //----------------------------------------------------------------
1259   2          
1260   2          SensorReadingProcess();
1261   2          TX_Wait_Process();
1262   2          App_RF_TxProcess();
1263   2      
C51 COMPILER V9.53.0.0   IB_MAIN_SEN                                                       01/28/2020 11:28:56 PAGE 22  

1264   2          // Kong.sh 191225 --> ÇÏ±â 3°³ ÇÔ¼ö¸¦ ½ÇÇàÇÏÁö ¾ÊÀ»½Ã¿¡ ¾à 5~6ºÐ Loop µ¿ÀÛÈÄ ¸ØÃß´Â Áõ»óÀÌ ¹ß»ý.. Why?
1265   2          #if _EPAS_MODE
1266   2          //--- No Function
1267   2          #else
                  ZAPP_CommandInterface();      // UART cmd Ã³¸®
                  ZAPP_PairingProcess();
                  LED_Process();
                  #endif
1272   2        }
1273   1      }
1274          #endif 


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4207    ----
   CONSTANT SIZE    =    558    ----
   XDATA SIZE       =     45      92
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
